<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>STXXL: Efficient Sequential Reading and Writing to Vectors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">STXXL
   &#160;<span id="projectnumber">1.4.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_vector_buf.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Efficient Sequential Reading and Writing to Vectors </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Timo Bingmann (2013)</dd></dl>
<p>The <a class="el" href="classstxxl_1_1vector.html" title="External vector container.  Introduction to vector container: see STXXL Vector tutorial.  Design and Internals of vector container: see Vector. ">stxxl::vector</a> is a very versatile container and it allows sequential access loops like the following:</p>
<div class="fragment"><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector.html">stxxl::VECTOR_GENERATOR&lt;uint64&gt;::result</a> vector_type;</div>
<div class="line"></div>
<div class="line">    vector_type vec(size);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">uint64</a> i = 0; i &lt; vec.size(); ++i)</div>
<div class="line">        vec[i] = (i % 1024);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">uint64</a> sum = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">uint64</a> i = 0; i &lt; vec.size(); ++i)</div>
<div class="line">        sum += vec[i];</div>
</div><!-- fragment --><p> However, these sequential loops using element access are <b>not very efficient</b> (see the experimental results below). Each <code>operator</code>[] is processed by the vector paging mechanism, and returns a writeable reference to the element. Because the reference might be modified, the vector must assume that the accessed page is dirty. Thus the read loop will actually rewrite the whole vector.</p>
<p>This effect can be avoided using a <code>const vector&amp;</code> or <a class="el" href="classstxxl_1_1vector.html#a29125fa34b555a1c209f23d00600d75c" title="constant iterator used to iterate through a vector, see More Notes. ">vector::const_iterator</a> as shown in the following:</p>
<div class="fragment"><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector.html">stxxl::VECTOR_GENERATOR&lt;uint64&gt;::result</a> vector_type;</div>
<div class="line"></div>
<div class="line">    vector_type vec(size);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">uint64</a> i = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (vector_type::iterator it = vec.begin(); it != vec.end(); ++it, ++i)</div>
<div class="line">        *it = (i % 1024);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">uint64</a> sum = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (vector_type::const_iterator it = vec.begin(); it != vec.end(); ++it)</div>
<div class="line">        sum += *it;</div>
</div><!-- fragment --><p> This method is already pretty good, but one can achieve even better performance. The problem with iterators is that all accesses still go through the vector's paging algorithms, possibly updating the internal paging algorithm's state. More importantly, the access operators do not use prefetching. For this purpose STXXL provides buffered reading and writing to vector ranges. These utilized asynchronous I/O and will thus <b>will overlap I/O with computation</b>.</p>
<p>The two basic classes to efficiently read and write vector are <a class="el" href="classstxxl_1_1vector__bufreader.html" title="Buffered sequential reader from a vector using overlapped I/O. ">vector_bufreader</a> and <a class="el" href="classstxxl_1_1vector__bufwriter.html" title="Buffered sequential writer to a vector using overlapped I/O. ">vector_bufwriter</a>. Their interface is a combination of the <code>stream</code> interface and iostreams. The two classes are more conveniently accessible via <a class="el" href="classstxxl_1_1vector.html#afe1c96e2c3614484466cf75cdef4bc89" title="vector_bufreader compatible with this vector ">vector::bufreader_type</a> and <a class="el" href="classstxxl_1_1vector.html#ab3407687424ff8d119fc3c9805511cdd" title="vector_bufwriter compatible with this vector ">vector::bufwriter_type</a>.</p>
<div class="fragment"><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector.html">stxxl::VECTOR_GENERATOR&lt;uint64&gt;::result</a> vector_type;</div>
<div class="line"></div>
<div class="line">    vector_type vec(size);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// write using vector_bufwriter</span></div>
<div class="line">    vector_type::bufwriter_type writer(vec);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">uint64</a> i = 0; i &lt; vec.size(); ++i)</div>
<div class="line">        writer &lt;&lt; (i % 1024);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// required to flush out the last block (or destruct the bufwriter)</span></div>
<div class="line">    writer.finish();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// now read using vector_bufreader</span></div>
<div class="line">    <a class="code" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">uint64</a> sum = 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (vector_type::bufreader_type reader(vec); !reader.empty(); ++reader)</div>
<div class="line">    {</div>
<div class="line">        sum += *reader;</div>
<div class="line">    }</div>
</div><!-- fragment --><p> When using <a class="el" href="classstxxl_1_1vector__bufwriter.html" title="Buffered sequential writer to a vector using overlapped I/O. ">vector_bufwriter</a> the vector's size <em>should</em> be allocated in advance. However, this is not required: when reaching the end of the vector, the buffered writer will automatically double the vector's size. Thus writing will not produce segfaults; however, doubling may go wrong for huge vectors.</p>
<p>Note that the same efficiency can be achieved using stream functions: <a class="el" href="classstxxl_1_1stream_1_1vector__iterator2stream.html" title="A model of stream that retrieves data from an external stxxl::vector iterator. It is more efficient t...">stream::vector_iterator2stream</a> and <a class="el" href="group__streampack.html#gabaafb435e850ebfdef01728414b673f8" title="Stores consecutively stream content to an output iterator. ">stream::materialize</a> also use overlapping I/O.</p>
<p>As last method, which is currently supported by STXXL, one can iterate over the vector using C++11's <code>auto</code> <code>for</code> loop construct:</p>
<div class="fragment"><div class="line">    <span class="comment">// now using vector_bufreader adaptor to C++11 for loop</span></div>
<div class="line">    <a class="code" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">uint64</a> sum = 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it : vector_type::bufreader_type(vec))</div>
<div class="line">    {</div>
<div class="line">        sum += it;</div>
<div class="line">    }</div>
</div><!-- fragment --><p> Note that we must construct a buffered reader explicitly, because just stating <code>"vec"</code> would amount to using the usual iterators (with pager). Support for C++11 is still experimental.</p>
<p>All source code from this example is available in <a class="el" href="examples_2containers_2vector_buf_8cpp-example.html">examples/containers/vector_buf.cpp</a>. The program also check the sum results and measures the time.</p>
<p>The following experimental results are from a machine with four disks: </p>
<pre class="fragment">$ vector_buf 64
[STXXL-MSG] STXXL v1.4.0 (prerelease)
[STXXL-MSG] Disk '/data01/stxxl' is allocated, space: 162124 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] Disk '/data02/stxxl' is allocated, space: 228881 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] Disk '/data03/stxxl' is allocated, space: 228881 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] Disk '/data04/stxxl' is allocated, space: 228881 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] In total 4 disks are allocated, space: 848770 MiB
[STXXL-MSG] Starting vector element access
sum: 4393751543808
[STXXL-MSG] Finished vector element access after 848.695 seconds. Processed 128.000 GiB @ 154.439 MiB/s
[STXXL-MSG] Starting vector iterator access
sum: 4393751543808
[STXXL-MSG] Finished vector iterator access after 540.938 seconds. Processed 128.000 GiB @ 242.305 MiB/s
[STXXL-MSG] Starting vector buffered access
sum: 4393751543808
[STXXL-MSG] Finished vector buffered access after 441.26 seconds. Processed 128.000 GiB @ 297.040 MiB/s
[STXXL-MSG] Starting vector C++11 loop access
sum: 4393751543808
[STXXL-MSG] Finished vector C++11 loop access after 440.977 seconds. Processed 128.000 GiB @ 297.231 MiB/s
</pre><p>Obviously, buffered access to <a class="el" href="classstxxl_1_1vector.html" title="External vector container.  Introduction to vector container: see STXXL Vector tutorial.  Design and Internals of vector container: see Vector. ">stxxl::vector</a> most efficient, where using const_iterators is only 18% slower. Just using element access via operator[] is not a good idea.</p>
<p>The difference between the methods grows smaller then using only one disk, because the I/O bandwidth decreases: </p>
<pre class="fragment">$ vector_buf 64
[STXXL-MSG] STXXL v1.4.0 (prerelease)
[STXXL-MSG] Disk '/data01/stxxl' is allocated, space: 162124 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] Starting vector element access
sum: 4393751543808
[STXXL-MSG] Finished vector element access after 2793.85 seconds. Processed 128.000 GiB @ 46.915 MiB/s
[STXXL-MSG] Starting vector iterator access
sum: 4393751543808
[STXXL-MSG] Finished vector iterator access after 1770.75 seconds. Processed 128.000 GiB @ 74.020 MiB/s
[STXXL-MSG] Starting vector buffered access
sum: 4393751543808
[STXXL-MSG] Finished vector buffered access after 1670.13 seconds. Processed 128.000 GiB @ 78.480 MiB/s
[STXXL-MSG] Starting vector C++11 loop access
sum: 4393751543808
[STXXL-MSG] Finished vector C++11 loop access after 1671.53 seconds. Processed 128.000 GiB @ 78.415 MiB/s
</pre><p>As a last note: there is also <a class="el" href="classstxxl_1_1vector__bufreader__reverse.html" title="Buffered sequential reverse reader from a vector using overlapped I/O. ">vector_bufreader_reverse</a> and <a class="el" href="classstxxl_1_1vector.html#af1c85f2004515cee06d7c0c108d8467a" title="vector_bufreader compatible with this vector ">vector::bufreader_reverse_type</a> for buffered reading in reverse. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Welcome to STXXL</a></li><li class="navelem"><a class="el" href="tutorial.html">Tutorials and Examples</a></li>
    <li class="footer"><a href="http://stxxl.sourceforge.net">STXXL 1.4.1</a> - Generated on Wed Oct 29 2014 10:13:29 for STXXL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
