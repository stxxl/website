<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>STXXL: Tutorial for the Stream Package</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">STXXL
   &#160;<span id="projectnumber">1.4.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_stream.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial for the Stream Package </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Timo Bingmann (2012-06-11)</dd></dl>
<p>This page gives a short introduction into the stream package. First the main abstractions are discussed and then some examples on how to utilize the existing algorithms are developed.</p>
<p>All example code can be found in <a class="el" href="examples_2stream_2stream1_8cpp-example.html">examples/stream/stream1.cpp</a></p>
<p>In <a class="el" href="tutorial_stream_edgesort.html">Generating Random Graphs using Streams</a> another example is given, where an existing algorithm is "pipelined".</p>
<h1><a class="anchor" id="stream1"></a>
Abstraction, Interface and a Simple Example</h1>
<p>The stream package is built around the abstract notion of an object being able to produce a sequence of output values. Only three simple operations are necessary:</p>
<ul>
<li>Retrieval of the current value: prefix <code>*</code> operator</li>
<li>Advance to the next value in the sequence: prefix <code>++</code> operator</li>
<li>Indication of the sequence's end: <code>empty()</code> function</li>
</ul>
<p>The most common place object that fits easily into this abstraction is the random generator. Actually, a random generator only requires two operations: it can be queried for its current value and be instructed to calculate/advance to new value. Of course the random sequence should be unbounded, so an <code>empty()</code> function would always be false. Nevertheless, this common-place example illustrates the purpose of the stream interface pretty well.</p>
<p>All stream objects must support the three operations above, they form the stream algorithm concept. In C++ a class conforms to this concept if it implements the following interface:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>stream_object</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Type of the values in the output sequence.</span></div>
<div class="line">    <span class="keyword">typedef</span> output_type value_type;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Retrieval prefix * operator (like dereferencing a pointer or iterator).</span></div>
<div class="line">    <span class="keyword">const</span> value_type&amp; operator* () <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prefix increment ++ operator, which advances the stream to the next value.</span></div>
<div class="line">    stream_object&amp; <a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator++ </a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Empty indicator. True if the last ++ operation could not fetch a value.</span></div>
<div class="line">    <span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>A very simple stream object that produces the sequence 1,2,3,4,....,1000 is shown in the following snippet:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>counter_object</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// This stream produces a sequence of integers.</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">int</span>         value_type;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// A class attribute to save the current value.</span></div>
<div class="line">    <span class="keywordtype">int</span>                 m_current_value;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// A constructor to set the initial value to 1.</span></div>
<div class="line">    counter_object()</div>
<div class="line">        : m_current_value(1)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The retrieve operator returning the current value.</span></div>
<div class="line">    <span class="keyword">const</span> value_type&amp; operator* ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> m_current_value;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Increment operator advancing to the next integer.</span></div>
<div class="line">    counter_object&amp; <a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator++ </a>()</div>
<div class="line">    {</div>
<div class="line">        ++m_current_value;</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Empty indicator, which in this case can check the current value.</span></div>
<div class="line">    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (m_current_value &gt; 1000);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>After this verbose interface definition, the actual iteration over a stream object can be done as follows:</p>
<div class="fragment"><div class="line">counter_object counter;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span> (!counter.empty())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; *counter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    ++counter;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>For those who like to shorten everything into fewer lines, the above can also be expressed as a for loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (counter_object cnt; !cnt.empty(); ++cnt)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; *cnt &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Both loops will print the following output: </p>
<pre class="fragment">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [...] 995 996 997 998 999 1000
</pre><h1><a class="anchor" id="stream2"></a>
Pipelining: Plugging Stream Objects Together</h1>
<p>The stream interface is so very useful for external memory algorithms because it represents the concept of sequential access to a stream of individual values. While the simple example above only works with integers, the <code>value_type</code> of streams will more often contain complex tuple structs with multiple components.</p>
<p>A stream algorithm can then be constructed from multiple stream objects that pass data from one to another. This notion of "plugging together" stream objects is used in the following example to calculate the square of each value of an integer sequence:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputStream&gt;</div>
<div class="line"><span class="keyword">struct </span>squaring_object</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// This stream produces a sequence of integers.</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">int</span>         value_type;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// A reference to another stream of integers, which are our input.</span></div>
<div class="line">    InputStream&amp;        m_input_stream;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// A temporary value buffer to hold the current square for retrieval.</span></div>
<div class="line">    value_type          m_current_value;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// A constructor taking another stream of integers as input.</span></div>
<div class="line">    squaring_object(InputStream&amp; input_stream)</div>
<div class="line">        : m_input_stream(input_stream)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!m_input_stream.empty())</div>
<div class="line">        {</div>
<div class="line">            m_current_value = *m_input_stream;</div>
<div class="line">            m_current_value = m_current_value * m_current_value;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The retrieve operator returning the square of the input stream.</span></div>
<div class="line">    <span class="keyword">const</span> value_type&amp; operator* ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> m_current_value;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Increment operator: handled by incrementing the input stream.</span></div>
<div class="line">    squaring_object&amp; <a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator++ </a>()</div>
<div class="line">    {</div>
<div class="line">        ++m_input_stream;</div>
<div class="line">        <span class="keywordflow">if</span> (!m_input_stream.empty())</div>
<div class="line">        {</div>
<div class="line">            m_current_value = *m_input_stream;</div>
<div class="line">            m_current_value = m_current_value * m_current_value;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Empty indicator: this stream is empty when the input stream is.</span></div>
<div class="line">    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> m_input_stream.empty();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>For a beginner in stream object programming, the squaring example contains multiple unexpected, verbose complications.</p>
<ul>
<li>We wish to allow many different integer sequences as input streams to the squaring class. For this we use template meta-programming and define squaring to take any class as <code>InputStream</code> template parameter. As yet, in C++ we cannot syntactically define which concepts the template parameters must fulfill, in this case one would require <code>InputStream</code> to implement the stream interface.</li>
<li>After defining the input stream class, one will usually need an instantiated object of that class inside the new stream class. Most common practice is to define references to other streams as class attributes, and have the actual objects be passed to the constructor of the new stream object. <br/>
 In the case of the squaring class, any <code>InputStream</code> object is accepted by the constructor and a reference is saved into <code>m_input_stream</code>.</li>
<li>As second attribute, the squaring class contains m_current_value. The additional temporary value is required in this case because <code>operator*()</code> must return a const-reference, so the square must actually be stored in a variable after it is calculated. Now note that the squaring operation in this version is implemented at two places: in the constructor and the <code><a class="el" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb" title="prefix increment operator (directly manipulates the integer parts) ">operator++()</a></code>. <br/>
 This is necessary, because the stream concept requires that the first value be <em>immediately available after construction</em>! Therefore it must be calculated in the constructor, and this code is usually a duplicate to the action done in <code><a class="el" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb" title="prefix increment operator (directly manipulates the integer parts) ">operator++()</a></code>. A real implementation would probably combine the calculation code into a <code>process()</code> function and also do additional allocation work in the constructor.</li>
</ul>
<p>An instance of the <code>counter_object</code> can be plugged into a <code>squaring_object</code> as done in the following example:</p>
<div class="fragment"><div class="line">counter_object counter;</div>
<div class="line">squaring_object&lt;counter_object&gt; squares(counter);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span> (!squares.empty())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; *squares &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    ++squares;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The example outputs:</p>
<pre class="fragment">1 4 9 16 25 36 49 64 81 100 121 144 169 [...] 986049 988036 990025 992016 994009 996004 998001 1000000
</pre><h1><a class="anchor" id="stream3"></a>
Miscellaneous Utilities Provided by the Stream Package</h1>
<p>The above examples are pure C++ interface manipulations and do not even require STXXL. However, when writing stream algorithms you can take advantage of the utilities provided by the stream package to create complex algorithms. Probably the most useful is the pair of sorting classes, which will be discussed after a few preliminaries.</p>
<p>More complex algorithms will most often use tuples as values passed from one stream to another. These tuples wrap all information fields of a specific piece of data. Simple tuples can be created using <code>std::pair</code>, tuples with larger number of components can use Boost.Tuple or just plain structs with multiple fields. (In the tuple case, the temporary value inside the stream struct can mostly be avoided.)</p>
<p>The stream package contains utilities to plug stream classes together to form complex algorithms. The following few examples are very basic algorithms:</p>
<p>Very often the input to a sequence of stream classes comes from an array or other container. In this case one requires an input stream object, which iterates through the container and outputs each element once. STXXL provides <a class="el" href="classstxxl_1_1stream_1_1iterator2stream.html" title="A model of stream that retrieves the data from an input iterator. For convenience use streamify funct...">iterator2stream</a> for this common purpose: </p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; intvector;</div>
<div class="line"><span class="comment">// (fill intvector)</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// define stream class iterating over an integer vector</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1stream_1_1iterator2stream.html">stxxl::stream::iterator2stream&lt; std::vector&lt;int&gt;::const_iterator</a> &gt; intstream_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// instantiate the stream object, iterate from begin to end of intvector.</span></div>
<div class="line">intstream_type intstream (intvector.begin(), intvector.end());</div>
<div class="line"></div>
<div class="line"><span class="comment">// plug in squaring object after vector iterator stream.</span></div>
<div class="line">squaring_object&lt;intstream_type&gt; squares(intstream);</div>
</div><!-- fragment --><p>Most important: if the input container is a <a class="el" href="classstxxl_1_1vector.html" title="External vector container.  Introduction to vector container: see STXXL Vector tutorial.  Design and Internals of vector container: see Vector. ">stxxl::vector</a>, then one should use <a class="el" href="classstxxl_1_1stream_1_1vector__iterator2stream.html" title="A model of stream that retrieves data from an external stxxl::vector iterator. It is more efficient t...">vector_iterator2stream</a>, because this class will prefetch additional blocks from the vector while processing the stream. </p>
<div class="fragment"><div class="line"><a class="code" href="classstxxl_1_1vector.html">stxxl::vector&lt;int&gt;</a> intvector;</div>
<div class="line"><span class="comment">// (fill intvector)</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// define stream class iterating over an integer STXXL vector</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1stream_1_1vector__iterator2stream.html">stxxl::stream::vector_iterator2stream&lt; stxxl::vector&lt;int&gt;::const_iterator</a> &gt; intstream_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// instantiate the stream object, iterate from begin to end of intvector using prefetching</span></div>
<div class="line">intstream_type intstream (intvector.<a class="code" href="classstxxl_1_1vector.html#aa4a96d116db4303b73c5bb23913661d9">begin</a>(), intvector.<a class="code" href="classstxxl_1_1vector.html#aa26fab42d8e28bf2d440158c97f8d52d">end</a>());</div>
<div class="line"></div>
<div class="line"><span class="comment">// plug in squaring object after vector iterator stream.</span></div>
<div class="line">squaring_object&lt;intstream_type&gt; squares(intstream);</div>
</div><!-- fragment --><p>The opposite to <a class="el" href="classstxxl_1_1stream_1_1iterator2stream.html" title="A model of stream that retrieves the data from an input iterator. For convenience use streamify funct...">iterator2stream</a> is to collect the output of a sequence of stream objects into a container or <a class="el" href="classstxxl_1_1vector.html" title="External vector container.  Introduction to vector container: see STXXL Vector tutorial.  Design and Internals of vector container: see Vector. ">stxxl::vector</a>. This operation is called <code>materialize</code> and also comes in the general version and a special version for the STXXL-vector, which uses asynchronous writes.</p>
<p>This example shows how to materialize a stream into a usual STL vector. </p>
<div class="fragment"><div class="line"><span class="comment">// construct the squared counter stream</span></div>
<div class="line">counter_object counter;</div>
<div class="line">squaring_object&lt;counter_object&gt; squares(counter);</div>
<div class="line"></div>
<div class="line"><span class="comment">// allocate vector of 100 integers</span></div>
<div class="line">std::vector&lt;int&gt; intvector (100);</div>
<div class="line"></div>
<div class="line"><span class="comment">// materialize 100 integers from stream and put into vector</span></div>
<div class="line"><a class="code" href="group__streampack.html#gabaafb435e850ebfdef01728414b673f8">stxxl::stream::materialize</a>(squares, intvector.<a class="code" href="classstxxl_1_1vector.html#aa4a96d116db4303b73c5bb23913661d9">begin</a>(), intvector.<a class="code" href="classstxxl_1_1vector.html#aa26fab42d8e28bf2d440158c97f8d52d">end</a>());</div>
</div><!-- fragment --><p>And the only modification needed to support larger data sets is to materialize to an STXXL vector: </p>
<div class="fragment"><div class="line"><span class="comment">// construct the squared counter stream</span></div>
<div class="line">counter_object counter;</div>
<div class="line">squaring_object&lt;counter_object&gt; squares(counter);</div>
<div class="line"></div>
<div class="line"><span class="comment">// allocate STXXL vector of 100 integers</span></div>
<div class="line"><a class="code" href="classstxxl_1_1vector.html">stxxl::vector&lt;int&gt;</a> intvector (100);</div>
<div class="line"></div>
<div class="line"><span class="comment">// materialize 100 integers from stream and put into STXXL vector</span></div>
<div class="line"><a class="code" href="group__streampack.html#gabaafb435e850ebfdef01728414b673f8">stxxl::stream::materialize</a>(squares, intvector.<a class="code" href="classstxxl_1_1vector.html#aa4a96d116db4303b73c5bb23913661d9">begin</a>(), intvector.<a class="code" href="classstxxl_1_1vector.html#aa26fab42d8e28bf2d440158c97f8d52d">end</a>());</div>
</div><!-- fragment --><h1><a class="anchor" id="stream4"></a>
Sorting As Provided by the Stream Package</h1>
<p>Maybe the most important set of tools in the stream package is the pairs of sorter classes <a class="el" href="classstxxl_1_1stream_1_1runs__creator.html" title="Forms sorted runs of data from a stream. ">runs_creator</a> and <a class="el" href="classstxxl_1_1stream_1_1runs__merger.html" title="Merges sorted runs. ">runs_merger</a>. The general way to sort a sequential input stream is to first consolidate a large number of input items in an internal memory buffer. Then when the buffer is full, it can be sorted in internal memory and subsequently written out to disk. This sorted sequence is then called a run. When the input stream is finished and the sorted output must be produced, theses sorted sequences can efficiently be merged using a tournament tree or similar multi-way comparison structure. (see <a class="el" href="design_algo_sorting.html">Parallel Disk Sorting</a>.)</p>
<p>STXXL implements this using two stream classes: <a class="el" href="classstxxl_1_1stream_1_1runs__creator.html" title="Forms sorted runs of data from a stream. ">runs_creator</a> and <a class="el" href="classstxxl_1_1stream_1_1runs__merger.html" title="Merges sorted runs. ">runs_merger</a>.</p>
<p>The following examples shows how to sort the integer sequence 1,2,...,1000 first by the right-most decimal digit, then by its absolute value (yes a somewhat constructed example, but it serves its purpose well.) For all sorters a comparator object is required which tells the sorter which of two objects is the smaller one. This is similar to the requirements of the usual STL, however, the STXXL sorters need to additional functions: <code>min_value()</code> and <code>max_value()</code> which are used as padding sentinels. These functions return the smallest and highest possible values of the given data type. </p>
<div class="fragment"><div class="line"><span class="comment">// define comparator class: compare right-most decimal and then absolute value</span></div>
<div class="line"><span class="keyword">struct </span>CompareMod10</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// comparison operator() returning true if (a &lt; b)</span></div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator() (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">if</span> ((a % 10) == (b % 10))</div>
<div class="line">            <span class="keywordflow">return</span> a &lt; b;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            <span class="keywordflow">return</span> (a % 10) &lt; (b % 10);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// smallest possible integer value</span></div>
<div class="line">    <span class="keywordtype">int</span> min_value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_MIN; }</div>
<div class="line">    <span class="comment">// largest possible integer value</span></div>
<div class="line">    <span class="keywordtype">int</span> max_value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_MAX; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>All sorters steps require an internal memory buffer. This size can be fixed using a parameter to <a class="el" href="classstxxl_1_1stream_1_1runs__creator.html" title="Forms sorted runs of data from a stream. ">runs_creator</a> and <a class="el" href="classstxxl_1_1stream_1_1runs__merger.html" title="Merges sorted runs. ">runs_merger</a>. The following example code instantiates a counter object, plugs this into a <a class="el" href="classstxxl_1_1stream_1_1runs__creator.html" title="Forms sorted runs of data from a stream. ">runs_creator</a> which is followed by a <a class="el" href="classstxxl_1_1stream_1_1runs__merger.html" title="Merges sorted runs. ">runs_merger</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> ram_use = 10*1024*1024;   <span class="comment">// amount of memory to use in runs creation</span></div>
<div class="line"></div>
<div class="line">counter_object  counter;        <span class="comment">// the counter stream from first examples</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// define a runs sorter for the counter stream which order by CompareMod10 object.</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">stxxl::stream::runs_creator&lt;counter_object, CompareMod10&gt;</a> rc_counter_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// instance of CompareMod10 comparator class</span></div>
<div class="line">CompareMod10    comparemod10;</div>
<div class="line"></div>
<div class="line"><span class="comment">// instance of runs_creator which reads the counter stream.</span></div>
<div class="line">rc_counter_type rc_counter (counter, comparemod10, ram_use);</div>
<div class="line"></div>
<div class="line"><span class="comment">// define a runs merger for the sorted runs from rc_counter.</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">stxxl::stream::runs_merger&lt;rc_counter_type::sorted_runs_type, CompareMod10&gt;</a> rm_counter_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// instance of runs_merger which merges sorted runs from rc_counter.</span></div>
<div class="line">rm_counter_type rm_counter (rc_counter.result(), comparemod10, ram_use);</div>
<div class="line"></div>
<div class="line"><span class="comment">// read sorted stream: runs_merger also conforms to the stream interface.</span></div>
<div class="line"><span class="keywordflow">while</span> (!rm_counter.empty())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; *rm_counter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    ++rm_counter;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> The output of the code above is: </p>
<pre class="fragment">10 20 30 40 50 60 70 80 [...] 990 1000 1 11 21 31 41 51 61 [...] 909 919 929 939 949 959 969 979 989 999
</pre><p>Note that in the above example the input of the <a class="el" href="classstxxl_1_1stream_1_1runs__creator.html" title="Forms sorted runs of data from a stream. ">runs_creator</a> is itself a stream. If however the data is not naturally available as a stream, one can use a variant of <a class="el" href="classstxxl_1_1stream_1_1runs__creator.html" title="Forms sorted runs of data from a stream. ">runs_creator</a> which accepts input via a <code>push()</code> function. This is more useful when using an imperative programming style. Note that the <a class="el" href="classstxxl_1_1stream_1_1runs__merger.html" title="Merges sorted runs. ">runs_merger</a> does not change. </p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> ram_use = 10*1024*1024;   <span class="comment">// amount of memory to use in runs creation</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// define a runs sorter which accepts imperative push()s and orders by CompareMod10 object.</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">stxxl::stream::runs_creator&lt;stxxl::stream::use_push&lt;int&gt;</a>, CompareMod10&gt; rc_counter_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// instance of CompareMod10 comparator class.</span></div>
<div class="line">CompareMod10    comparemod10;</div>
<div class="line"></div>
<div class="line"><span class="comment">// instance of runs_creator which waits for input.</span></div>
<div class="line">rc_counter_type rc_counter (comparemod10, ram_use);</div>
<div class="line"></div>
<div class="line"><span class="comment">// write sequence of integers into runs</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 1000; ++i)</div>
<div class="line">    rc_counter.push(i);</div>
<div class="line"></div>
<div class="line"><span class="comment">// define a runs merger for the sorted runs from rc_counter.</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">stxxl::stream::runs_merger&lt;rc_counter_type::sorted_runs_type, CompareMod10&gt;</a> rm_counter_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// instance of runs_merger which merges sorted runs from rc_counter.</span></div>
<div class="line">rm_counter_type rm_counter (rc_counter.result(), comparemod10, ram_use);</div>
<div class="line"></div>
<div class="line"><span class="comment">// read sorted stream: runs_merger also conforms to the stream interface.</span></div>
<div class="line"><span class="keywordflow">while</span> (!rm_counter.empty())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; *rm_counter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    ++rm_counter;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>And as the last example in this tutorial we show how to use <a class="el" href="classstxxl_1_1sorter.html" title="External sorter container.   Introduction  to sorter container: see STXXL Sorter tutorial.   Design and Internals  of sorter container: see Sorter. ">stxxl::sorter</a>, which combines <a class="el" href="classstxxl_1_1stream_1_1runs__creator.html" title="Forms sorted runs of data from a stream. ">runs_creator</a> and <a class="el" href="classstxxl_1_1stream_1_1runs__merger.html" title="Merges sorted runs. ">runs_merger</a> into one object. The sorter has two states: input and output. During input, new elements can be sorted using <code>push()</code>. Then to switch to output state, the function <code><a class="el" href="group__stlalgo.html#ga5fcb89548cf48f273e140e973af6df33" title="Sort records comparison-based, see stxxl::sort -- Sorting Comparison-Based. ">sort()</a></code> is called, after which the sorter can be queried using the usual stream interface. </p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> ram_use = 10*1024*1024;   <span class="comment">// amount of memory to use in runs creation</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// define a runs sorter which accepts imperative push()s and orders by CompareMod10 object.</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1sorter.html">stxxl::sorter&lt;int, CompareMod10&gt;</a> sr_counter_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// instance of CompareMod10 comparator class.</span></div>
<div class="line">CompareMod10    comparemod10;</div>
<div class="line"></div>
<div class="line"><span class="comment">// instance of sorter which waits for input.</span></div>
<div class="line">sr_counter_type sr_counter (comparemod10, ram_use);</div>
<div class="line"></div>
<div class="line"><span class="comment">// write sequence of integers into sorter, which creates sorted runs</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 1000; ++i)</div>
<div class="line">    sr_counter.push(i);</div>
<div class="line"></div>
<div class="line"><span class="comment">// signal sorter that the input stream is finished and switch to output mode.</span></div>
<div class="line">sr_counter.sort();</div>
<div class="line"></div>
<div class="line"><span class="comment">// read sorted stream: sorter also conforms to the stream interface.</span></div>
<div class="line"><span class="keywordflow">while</span> (!sr_counter.empty())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; *sr_counter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    ++sr_counter;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>All three examples have the same output. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Welcome to STXXL</a></li><li class="navelem"><a class="el" href="tutorial.html">Tutorials and Examples</a></li>
    <li class="footer"><a href="http://stxxl.sourceforge.net">STXXL 1.4.1</a> - Generated on Wed Oct 29 2014 10:13:29 for STXXL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
