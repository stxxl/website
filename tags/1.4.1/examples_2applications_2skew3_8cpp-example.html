<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>STXXL: examples/applications/skew3.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">STXXL
   &#160;<span id="projectnumber">1.4.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('examples_2applications_2skew3_8cpp-example.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">examples/applications/skew3.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">/***************************************************************************</span></div>
<div class="line"><span class="comment"> *  examples/applications/skew3.cpp</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  Implementation of the external memory suffix sorting algorithm DC3 aka</span></div>
<div class="line"><span class="comment"> *  skew3 as described in Roman Dementiev, Juha Kaerkkaeinen, Jens Mehnert and</span></div>
<div class="line"><span class="comment"> *  Peter Sanders. &quot;Better External Memory Suffix Array Construction&quot;. Journal</span></div>
<div class="line"><span class="comment"> *  of Experimental Algorithmics (JEA), volume 12, 2008.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  Part of the STXXL. See http://stxxl.sourceforge.net</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  Copyright (C) 2004 Jens Mehnert &lt;jmehnert@mpi-sb.mpg.de&gt;</span></div>
<div class="line"><span class="comment"> *  Copyright (C) 2012-2013 Timo Bingmann &lt;tb@panthema.net&gt;</span></div>
<div class="line"><span class="comment"> *  Copyright (C) 2012-2013 Daniel Feist &lt;daniel.feist@student.kit.edu&gt;</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment"> *  (See accompanying file LICENSE_1_0.txt or copy at</span></div>
<div class="line"><span class="comment"> *  http://www.boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> **************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="algorithm.html">algorithm</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstddef&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector.html">vector</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="algorithm.html">stxxl/algorithm</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cmdline.html">stxxl/cmdline</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io.html">stxxl/io</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random.html">stxxl/random</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sorter.html">stxxl/sorter</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stats.html">stxxl/stats</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stream.html">stxxl/stream</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector.html">stxxl/vector</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uint__types_8h.html">stxxl/bits/common/uint_types.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> <a name="a0"></a><a class="code" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">stxxl::uint64</a>;</div>
<div class="line"><span class="keyword">using</span> <a name="a1"></a><a class="code" href="namespacestxxl.html#a2617329df09b282880680c99e5326b2d">stxxl::internal_size_type</a>;</div>
<div class="line"><span class="keyword">using</span> <a name="a2"></a><a class="code" href="namespacestxxl.html#a8a46bdf85465a25d217c9e8894c98ef2">stxxl::external_size_type</a>;</div>
<div class="line"><span class="keyword">namespace </span>stream = stxxl::stream;</div>
<div class="line"></div>
<div class="line"><span class="comment">// 1 GiB ram used by external data structures / 1 MiB block size</span></div>
<div class="line"><a class="code" href="namespacestxxl.html#a2617329df09b282880680c99e5326b2d">internal_size_type</a> ram_use = 1024 * 1024 * 1024;</div>
<div class="line"></div>
<div class="line"><span class="comment">// alphabet data type</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> alphabet_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculation data type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="namespacestxxl.html#a8a46bdf85465a25d217c9e8894c98ef2">external_size_type</a> size_type;</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">/// Suffix Array checker for correctness verification</span></div>
<div class="line"><span class="comment"></span><span class="comment"></span></div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Algorithm to check whether the suffix array is correct. Loosely based on the</span></div>
<div class="line"><span class="comment"> * ideas of Kaerkkaeinen und Burghardt, originally implemented in STXXL by Jens</span></div>
<div class="line"><span class="comment"> * Mehnert (2004), reimplemented using triples by Timo Bingmann (2012).</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @param InputT is the original text, from which the suffix array was build</span></div>
<div class="line"><span class="comment"> * @param InputSA is the suffix array from InputT</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Note: ISA := The inverse of SA</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputT, <span class="keyword">typename</span> InputSA&gt;</div>
<div class="line"><span class="keywordtype">bool</span> sacheck(InputT&amp; inputT, InputSA&amp; inputSA)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> InputSA::value_type offset_type;</div>
<div class="line">    <span class="keyword">typedef</span> <a name="_a3"></a><a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple&lt;offset_type, offset_type&gt;</a> pair_type;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple&lt;offset_type, offset_type, offset_type&gt;</a> triple_type;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// *** Pipeline Declaration ***</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Build tuples with index: (SA[i]) -&gt; (i, SA[i])</span></div>
<div class="line">    <span class="keyword">typedef</span> <a name="_a4"></a><a class="code" href="structstxxl_1_1stream_1_1counter.html">stxxl::stream::counter&lt;offset_type&gt;</a> index_counter_type;</div>
<div class="line">    index_counter_type index_counter;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> stream::make_tuple&lt;index_counter_type, InputSA&gt; tuple_index_sa_type;</div>
<div class="line">    tuple_index_sa_type tuple_index_sa(index_counter, inputSA);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// take (i, SA[i]) and sort to (ISA[i], i)</span></div>
<div class="line">    <span class="keyword">typedef</span> <a name="_a5"></a><a class="code" href="structstxxl_1_1tuple__less2nd.html">stxxl::tuple_less2nd&lt;pair_type&gt;</a> pair_less_type;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::sort&lt;tuple_index_sa_type, pair_less_type&gt; build_isa_type;</div>
<div class="line"></div>
<div class="line">    build_isa_type build_isa(tuple_index_sa, pair_less_type(), ram_use / 3);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// build (ISA[i], T[i], ISA[i+1]) and sort to (i, T[SA[i]], ISA[SA[i]+1])</span></div>
<div class="line">    <span class="keyword">typedef</span> <a name="_a6"></a><a class="code" href="structstxxl_1_1tuple__less1st.html">stxxl::tuple_less1st&lt;triple_type&gt;</a> triple_less_type;      <span class="comment">// comparison relation</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::use_push&lt;triple_type&gt; triple_push_type; <span class="comment">// indicator use push()</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_creator&lt;triple_push_type, triple_less_type&gt; triple_rc_type;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_merger&lt;typename triple_rc_type::sorted_runs_type, triple_less_type&gt; triple_rm_type;</div>
<div class="line"></div>
<div class="line">    triple_rc_type triple_rc(triple_less_type(), ram_use / 3);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// ************************* Process ******************************</span></div>
<div class="line">    <span class="comment">// loop 1: read ISA and check for a permutation. Simultaneously create runs</span></div>
<div class="line">    <span class="comment">// of triples by iterating ISA and T.</span></div>
<div class="line"></div>
<div class="line">    size_type totalSize;</div>
<div class="line">    {</div>
<div class="line">        offset_type prev_isa = (*build_isa).first;</div>
<div class="line">        offset_type counter = 0;</div>
<div class="line">        <span class="keywordflow">while</span> (!build_isa.empty())</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> ((*build_isa).second != counter) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Error: suffix array is not a permutation of 0..n-1.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            ++counter;</div>
<div class="line">            ++build_isa; <span class="comment">// ISA is one in front of T</span></div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!build_isa.empty()) {</div>
<div class="line">                triple_rc.push(triple_type(prev_isa, *inputT, (*build_isa).first));</div>
<div class="line">                prev_isa = (*build_isa).first;</div>
<div class="line">            }</div>
<div class="line">            ++inputT;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        totalSize = counter;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (totalSize == 1) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// ************************************************************************</span></div>
<div class="line">    <span class="comment">// loop 2: read triples (i,T[SA[i]],ISA[SA[i]+1]) and check for correct</span></div>
<div class="line">    <span class="comment">// ordering.</span></div>
<div class="line"></div>
<div class="line">    triple_rm_type triple_rm(triple_rc.result(), triple_less_type(), ram_use / 3);</div>
<div class="line"></div>
<div class="line">    {</div>
<div class="line">        triple_type prev_triple = *triple_rm;</div>
<div class="line">        size_type counter = 0;</div>
<div class="line"></div>
<div class="line">        ++triple_rm;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">while</span> (!triple_rm.empty())</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> triple_type&amp; this_triple = *triple_rm;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (prev_triple.second &gt; this_triple.second)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// simple check of first character of suffix</span></div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Error: suffix array position &quot;</span> &lt;&lt; counter &lt;&lt; <span class="stringliteral">&quot; ordered incorrectly.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prev_triple.second == this_triple.second)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (this_triple.third == (offset_type)totalSize) {</div>
<div class="line">                    <span class="comment">// last suffix of string must be first among those with same</span></div>
<div class="line">                    <span class="comment">// first character</span></div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;Error: suffix array position &quot;</span> &lt;&lt; counter &lt;&lt; <span class="stringliteral">&quot; ordered incorrectly.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (prev_triple.third != (offset_type)totalSize &amp;&amp; prev_triple.third &gt; this_triple.third) {</div>
<div class="line">                    <span class="comment">// positions SA[i] and SA[i-1] has same first character but</span></div>
<div class="line">                    <span class="comment">// their suffixes are ordered incorrectly: the suffix</span></div>
<div class="line">                    <span class="comment">// position of SA[i] is given by ISA[SA[i]]</span></div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;Error: suffix array position &quot;</span> &lt;&lt; counter &lt;&lt; <span class="stringliteral">&quot; ordered incorrectly.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            prev_triple = this_triple;</div>
<div class="line"></div>
<div class="line">            ++triple_rm;</div>
<div class="line">            ++counter;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputT, <span class="keyword">typename</span> InputSA&gt;</div>
<div class="line"><span class="keywordtype">bool</span> sacheck_vectors(InputT&amp; inputT, InputSA&amp; inputSA)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typename</span> stream::streamify_traits&lt;typename InputT::iterator&gt;::stream_type streamT</div>
<div class="line">        = <a name="a7"></a><a class="code" href="group__streampack.html#gac77a17eb336aaef37623e644c3b9a7cb">stream::streamify</a>(inputT.begin(), inputT.end());</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> stream::streamify_traits&lt;typename InputSA::iterator&gt;::stream_type streamSA</div>
<div class="line">        = <a class="code" href="group__streampack.html#gac77a17eb336aaef37623e644c3b9a7cb">stream::streamify</a>(inputSA.begin(), inputSA.end());</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> sacheck(streamT, streamSA);</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">/// DC3 aka skew algorithm</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * DC3 aka skew algorithm a short description. T := input string</span></div>
<div class="line"><span class="comment"> * The recursion works as follows:</span></div>
<div class="line"><span class="comment"> * Step 1: a) pick all mod1/mod2 triples (i.e. triples T[i,i+2] at position i mod 3 != 0) (-&gt; extract_mod12 class)</span></div>
<div class="line"><span class="comment"> *         b) sort mod1/mod2 triples lexicographically (-&gt; build_sa class)</span></div>
<div class="line"><span class="comment"> *         c) give mod1/mod2 triples lexicographical ascending names n (-&gt; naming class)</span></div>
<div class="line"><span class="comment"> *         d) check lexicographical names for uniqueness (-&gt; naming class)</span></div>
<div class="line"><span class="comment"> *            If yes: proceed to next Step, If no: set T := lexicographical names and run Step 1 again</span></div>
<div class="line"><span class="comment"> * Step 2: a) by sorting the lexicographical names n we receive ranks r</span></div>
<div class="line"><span class="comment"> *         b) construct mod0-quints, mod1-quads and mod2-quints  (-&gt; build_sa class)</span></div>
<div class="line"><span class="comment"> *         c) prepare for merging by:</span></div>
<div class="line"><span class="comment"> *            sort mod0-quints by 2 components, sort mod1-quads / mod2-quints by one component (-&gt; build_sa class)</span></div>
<div class="line"><span class="comment"> *         c) merge mod0-quints, mod1-quads and mod2-quints (-&gt; merge_sa class)</span></div>
<div class="line"><span class="comment"> * Step 3: a) return Suffix Array of T</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @param offset_type later suffix array data type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> offset_type&gt;</div>
<div class="line"><span class="keyword">class </span>skew</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// 2-tuple, 3-tuple, 4-tuple (=quads), 5-tuple(=quints) definition</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple&lt;offset_type, offset_type&gt;</a> skew_pair_type;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple&lt;offset_type, offset_type, offset_type&gt;</a> skew_triple_type;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple&lt;offset_type, offset_type, offset_type, offset_type&gt;</a> skew_quad_type;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple&lt;offset_type, offset_type, offset_type, offset_type, offset_type&gt;</a> skew_quint_type;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a name="_a8"></a><a class="code" href="classstxxl_1_1vector.html">stxxl::VECTOR_GENERATOR&lt;offset_type, 1, 2&gt;::result</a> offset_array_type;</div>
<div class="line">    <span class="keyword">typedef</span> stream::vector_iterator2stream&lt;typename offset_array_type::iterator&gt; offset_array_it_rg;</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /** Comparison function for the mod0 tuples. */</span></div>
<div class="line">    <span class="keyword">struct </span>less_mod0</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">typedef</span> skew_quint_type value_type;</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> value_type&amp; a, <span class="keyword">const</span> value_type&amp; b)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">if</span> (a.second == b.second)</div>
<div class="line">                <span class="keywordflow">return</span> a.fourth &lt; b.fourth;</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                <span class="keywordflow">return</span> a.second &lt; b.second;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">static</span> value_type min_value() { <span class="keywordflow">return</span> value_type::min_value(); }</div>
<div class="line">        <span class="keyword">static</span> value_type max_value() { <span class="keywordflow">return</span> value_type::max_value(); }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple__less2nd.html">stxxl::tuple_less2nd&lt;skew_quad_type&gt;</a> less_mod1;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple__less2nd.html">stxxl::tuple_less2nd&lt;skew_quint_type&gt;</a> less_mod2;</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /** Put the (0 mod 2) [which are the 1,2 mod 3 tuples] tuples at the begin. */</span></div>
<div class="line">    <span class="keyword">struct </span>less_skew</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">typedef</span> skew_pair_type value_type;</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> value_type&amp; a, <span class="keyword">const</span> value_type&amp; b)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">if</span> ((a.first &amp; 1) == (b.first &amp; 1))</div>
<div class="line">                <span class="keywordflow">return</span> a.first &lt; b.first;</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                <span class="keywordflow">return</span> (a.first &amp; 1) &lt; (b.first &amp; 1);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">static</span> value_type min_value() { <span class="keywordflow">return</span> value_type::min_value(); }</div>
<div class="line">        <span class="keyword">static</span> value_type max_value() { <span class="keywordflow">return</span> value_type::max_value(); }</div>
<div class="line">    };</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /** Sort skew_quad datatype. */</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> alphabet_type&gt;</div>
<div class="line">    <span class="keyword">struct </span>less_quad</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple&lt;offset_type, alphabet_type, alphabet_type, alphabet_type&gt;</a> value_type;</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> value_type&amp; a, <span class="keyword">const</span> value_type&amp; b)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">if</span> (a.second == b.second) {</div>
<div class="line">                <span class="keywordflow">if</span> (a.third == b.third)</div>
<div class="line">                    <span class="keywordflow">return</span> a.<a name="a9"></a><a class="code" href="structstxxl_1_1tuple.html#ae5006a18c0316af2bb8428e6ed220161">fourth</a> &lt; b.fourth;</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    <span class="keywordflow">return</span> a.third &lt; b.third;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                <span class="keywordflow">return</span> a.second &lt; b.second;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">static</span> value_type min_value() { <span class="keywordflow">return</span> value_type::min_value(); }</div>
<div class="line">        <span class="keyword">static</span> value_type max_value() { <span class="keywordflow">return</span> value_type::max_value(); }</div>
<div class="line">    };</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /** Check, if last two components of tree quads are equal. */</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> quad_type&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> quad_eq(<span class="keyword">const</span> quad_type&amp; a, <span class="keyword">const</span> quad_type&amp; b)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (a.second == b.second) &amp;&amp; (a.third == b.third) &amp;&amp; (a.fourth == b.fourth);</div>
<div class="line">    }</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /** Naming pipe for the conventional skew algorithm without discarding. */</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Input&gt;</div>
<div class="line">    <span class="keyword">class </span>naming</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Input::value_type quad_type;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">typedef</span> skew_pair_type value_type;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        Input&amp; A;</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span>&amp; unique;</div>
<div class="line">        offset_type lexname;</div>
<div class="line">        quad_type prev;</div>
<div class="line">        skew_pair_type result;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        naming(Input&amp; A_, <span class="keywordtype">bool</span>&amp; unique_)</div>
<div class="line">            : A(A_), unique(unique_), lexname(0)</div>
<div class="line">        {</div>
<div class="line">            assert(!A.empty());</div>
<div class="line">            unique = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">            prev = *A;</div>
<div class="line">            result.first = prev.first;</div>
<div class="line">            result.second = lexname;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> result;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        naming&amp; <a name="a10"></a><a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator ++ </a>()</div>
<div class="line">        {</div>
<div class="line">            assert(!A.empty());</div>
<div class="line"></div>
<div class="line">            ++A;</div>
<div class="line">            <span class="keywordflow">if</span> (A.empty())</div>
<div class="line">                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">            quad_type curr = *A;</div>
<div class="line">            <span class="keywordflow">if</span> (!quad_eq(prev, curr)) {</div>
<div class="line">                ++lexname;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">if</span> (!A.empty() &amp;&amp; curr.second != offset_type(0)) {</div>
<div class="line">                    unique = <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            result.first = curr.first;</div>
<div class="line">            result.second = lexname;</div>
<div class="line"></div>
<div class="line">            prev = curr;</div>
<div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> A.empty();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /** Create tuples of 2 components until one of the input streams are empty. */</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputA, <span class="keyword">class</span> InputB, const <span class="keywordtype">int</span> add_alphabet = 0&gt;</div>
<div class="line">    <span class="keyword">class </span>make_pairs</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple&lt;typename InputA::value_type, offset_type&gt;</a> value_type;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        InputA&amp; A;</div>
<div class="line">        InputB&amp; B;</div>
<div class="line">        value_type result;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        make_pairs(InputA&amp; a, InputB&amp; b)</div>
<div class="line">            : A(a), B(b)</div>
<div class="line">        {</div>
<div class="line">            assert(!A.empty());</div>
<div class="line">            assert(!B.empty());</div>
<div class="line">            <span class="keywordflow">if</span> (!empty()) {</div>
<div class="line">                result = value_type(*A, *B + add_alphabet);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{ <span class="keywordflow">return</span> result; }</div>
<div class="line"></div>
<div class="line">        make_pairs&amp; <a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator ++ </a>()</div>
<div class="line">        {</div>
<div class="line">            assert(!A.empty());</div>
<div class="line">            assert(!B.empty());</div>
<div class="line"></div>
<div class="line">            ++A;</div>
<div class="line">            ++B;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!A.empty() &amp;&amp; !B.empty()) {</div>
<div class="line">                result = value_type(*A, *B + add_alphabet);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{ <span class="keywordflow">return</span> (A.empty() || B.empty()); }</div>
<div class="line">    };</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Collect three characters t_i, t_{i+1}, t_{i+2} beginning at the index</span></div>
<div class="line"><span class="comment">     * i. Since we need at least one unique endcaracter, we free the first</span></div>
<div class="line"><span class="comment">     * characters i.e. we map (t_i) -&gt; (i,t_i,t_{i+1},t_{i+2})</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     * @param Input holds all characters t_i from input string t</span></div>
<div class="line"><span class="comment">     * @param alphabet_type</span></div>
<div class="line"><span class="comment">     * @param add_alphabet</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Input, <span class="keyword">typename</span> alphabet_type, const <span class="keywordtype">int</span> add_alphabet = 0&gt;</div>
<div class="line">    <span class="keyword">class </span>make_quads</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple&lt;offset_type, alphabet_type, alphabet_type, alphabet_type&gt;</a> value_type;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        Input&amp; A;</div>
<div class="line">        value_type current;</div>
<div class="line">        offset_type counter;</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z3z;  <span class="comment">// = counter mod 3, (&quot;+&quot;,Z/3Z) is cheaper than %</span></div>
<div class="line">        <span class="keywordtype">bool</span> finished;</div>
<div class="line"></div>
<div class="line">        offset_array_type&amp; text;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        make_quads(Input&amp; data_in_, offset_array_type&amp; text_)</div>
<div class="line">            : A(data_in_),</div>
<div class="line">              current(0, 0, 0, 0),</div>
<div class="line">              counter(0),</div>
<div class="line">              z3z(0),</div>
<div class="line">              finished(false),</div>
<div class="line">              text(text_)</div>
<div class="line">        {</div>
<div class="line">            assert(!A.empty());</div>
<div class="line"></div>
<div class="line">            current.first = counter;</div>
<div class="line">            current.second = (*A).second + add_alphabet;</div>
<div class="line">            ++A;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!A.empty()) {</div>
<div class="line">                current.third = (*A).second + add_alphabet;</div>
<div class="line">                ++A;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                current.third = 0;</div>
<div class="line">                current.fourth = 0;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!A.empty()) {</div>
<div class="line">                current.fourth = (*A).second + add_alphabet;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                current.fourth = 0;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{ <span class="keywordflow">return</span> current; }</div>
<div class="line"></div>
<div class="line">        make_quads&amp; <a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator ++ </a>()</div>
<div class="line">        {</div>
<div class="line">            assert(!A.empty() || !finished);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (current.second != offset_type(0)) {</div>
<div class="line">                text.push_back(current.second);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Calculate module</span></div>
<div class="line">            <span class="keywordflow">if</span> (++z3z == 3) z3z = 0;</div>
<div class="line"></div>
<div class="line">            current.first = ++counter;</div>
<div class="line">            current.second = current.third;</div>
<div class="line">            current.third = current.fourth;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!A.empty())</div>
<div class="line">                ++A;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!A.empty()) {</div>
<div class="line">                current.fourth = (*A).second + add_alphabet;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                current.fourth = 0;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Inserts a dummy tuple for input sizes of n%3==1</span></div>
<div class="line">            <span class="keywordflow">if</span> ((current.second == offset_type(0)) &amp;&amp; (z3z != 1)) {</div>
<div class="line">                finished = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{ <span class="keywordflow">return</span> (A.empty() &amp;&amp; finished); }</div>
<div class="line">    };</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /** Drop 1/3 of the input. More exactly the offsets at positions (0 mod</span></div>
<div class="line"><span class="comment">     * 3). Index begins with 0. */</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Input&gt;</div>
<div class="line">    <span class="keyword">class </span>extract_mod12</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Input::value_type value_type;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        Input&amp; A;</div>
<div class="line">        offset_type counter;</div>
<div class="line">        offset_type output_counter;</div>
<div class="line">        value_type result;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        extract_mod12(Input&amp; A_)</div>
<div class="line">            : A(A_),</div>
<div class="line">              counter(0),</div>
<div class="line">              output_counter(0)</div>
<div class="line">        {</div>
<div class="line">            assert(!A.empty());</div>
<div class="line">            ++A, ++counter;  <span class="comment">// skip 0 = mod0 offset</span></div>
<div class="line">            <span class="keywordflow">if</span> (!A.empty()) {</div>
<div class="line">                result = *A;</div>
<div class="line">                result.first = output_counter;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{ <span class="keywordflow">return</span> result; }</div>
<div class="line"></div>
<div class="line">        extract_mod12&amp; <a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator ++ </a>()</div>
<div class="line">        {</div>
<div class="line">            assert(!A.empty());</div>
<div class="line"></div>
<div class="line">            ++A, ++counter, ++output_counter;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!A.empty() &amp;&amp; (counter % 3) == 0) {</div>
<div class="line">                <span class="comment">// skip mod0 offsets</span></div>
<div class="line">                ++A, ++counter;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (!A.empty()) {</div>
<div class="line">                result = *A;</div>
<div class="line">                result.first = output_counter;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{ <span class="keywordflow">return</span> A.empty(); }</div>
<div class="line">    };</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /** Create the suffix array from the current sub problem by simple</span></div>
<div class="line"><span class="comment">     *  comparison-based merging.  More precisely: compare characters(out of</span></div>
<div class="line"><span class="comment">     *  text t) and ranks(out of ISA12) of the following constellation:</span></div>
<div class="line"><span class="comment">     *  Input constellation:</span></div>
<div class="line"><span class="comment">     *  @param Mod0 5-tuple (quint): &lt;i, t_i, t_{i+1}, ISA12[i+1], ISA12[i+2]&gt;</span></div>
<div class="line"><span class="comment">     *  @param Mod1 4-tuple (quad): &lt;i, ISA12[i], t_i, ISA12[i+1]&gt;</span></div>
<div class="line"><span class="comment">     *  @param Mod2 5-tuple (quint): &lt;i, ISA[i], t_i, t_{i+1}, ISA12[i+1]&gt;</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Mod0, <span class="keyword">class</span> Mod1, <span class="keyword">class</span> Mod2&gt;</div>
<div class="line">    <span class="keyword">class </span>merge_sa</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> offset_type value_type;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        Mod0&amp; A;</div>
<div class="line">        Mod1&amp; B;</div>
<div class="line">        Mod2&amp; C;</div>
<div class="line"></div>
<div class="line">        skew_quint_type s0;</div>
<div class="line">        skew_quad_type s1;</div>
<div class="line">        skew_quint_type s2;</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">int</span> selected;</div>
<div class="line">        <span class="keywordtype">bool</span> done[3];</div>
<div class="line"></div>
<div class="line">        offset_type index;</div>
<div class="line">        offset_type merge_result;</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> cmp_mod1_less_mod2()</div>
<div class="line">        {</div>
<div class="line">            assert(!done[1] &amp;&amp; !done[2]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> s1.second &lt; s2.second;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> cmp_mod0_less_mod2()</div>
<div class="line">        {</div>
<div class="line">            assert(!done[0] &amp;&amp; !done[2]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (s0.second == s2.third) {</div>
<div class="line">                <span class="keywordflow">if</span> (s0.third == s2.fourth)</div>
<div class="line">                    <span class="keywordflow">return</span> s0.fifth &lt; s2.fifth;</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    <span class="keywordflow">return</span> s0.third &lt; s2.fourth;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                <span class="keywordflow">return</span> s0.second &lt; s2.third;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> cmp_mod0_less_mod1()</div>
<div class="line">        {</div>
<div class="line">            assert(!done[0] &amp;&amp; !done[1]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (s0.second == s1.third)</div>
<div class="line">                <span class="keywordflow">return</span> s0.fourth &lt; s1.fourth;</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                <span class="keywordflow">return</span> s0.second &lt; s1.third;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> merge()</div>
<div class="line">        {</div>
<div class="line">            assert(!done[0] || !done[1] || !done[2]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (done[0])</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (done[2] || (!done[1] &amp;&amp; cmp_mod1_less_mod2()))</div>
<div class="line">                {</div>
<div class="line">                    selected = 1;</div>
<div class="line">                    merge_result = s1.first;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    selected = 2;</div>
<div class="line">                    merge_result = s2.first;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (done[1] || cmp_mod0_less_mod1())</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (done[2] || cmp_mod0_less_mod2())</div>
<div class="line">                {</div>
<div class="line">                    selected = 0;</div>
<div class="line">                    merge_result = s0.first;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    selected = 2;</div>
<div class="line">                    merge_result = s2.first;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (done[2] || cmp_mod1_less_mod2())</div>
<div class="line">                {</div>
<div class="line">                    selected = 1;</div>
<div class="line">                    merge_result = s1.first;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    selected = 2;</div>
<div class="line">                    merge_result = s2.first;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            assert(!done[selected]);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> (A.empty() &amp;&amp; B.empty() &amp;&amp; C.empty());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        merge_sa(Mod0&amp; x1, Mod1&amp; x2, Mod2&amp; x3)</div>
<div class="line">            : A(x1), B(x2), C(x3), selected(-1), index(0)</div>
<div class="line">        {</div>
<div class="line">            assert(!A.empty());</div>
<div class="line">            assert(!B.empty());</div>
<div class="line">            assert(!C.empty());</div>
<div class="line">            done[0] = <span class="keyword">false</span>;</div>
<div class="line">            done[1] = <span class="keyword">false</span>;</div>
<div class="line">            done[2] = <span class="keyword">false</span>;</div>
<div class="line">            s0 = *A;</div>
<div class="line">            s1 = *B;</div>
<div class="line">            s2 = *C;</div>
<div class="line"></div>
<div class="line">            merge();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> merge_result;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        merge_sa&amp; <a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator ++ </a>()</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (selected == 0) {</div>
<div class="line">                assert(!A.empty());</div>
<div class="line">                ++A;</div>
<div class="line">                <span class="keywordflow">if</span> (!A.empty())</div>
<div class="line">                    s0 = *A;</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    done[0] = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (selected == 1) {</div>
<div class="line">                assert(!B.empty());</div>
<div class="line">                ++B;</div>
<div class="line">                <span class="keywordflow">if</span> (!B.empty())</div>
<div class="line">                    s1 = *B;</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    done[1] = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                assert(!C.empty());</div>
<div class="line">                assert(selected == 2);</div>
<div class="line">                ++C;</div>
<div class="line">                <span class="keywordflow">if</span> (!C.empty())</div>
<div class="line">                    s2 = *C;</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    done[2] = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            ++index;</div>
<div class="line">            <span class="keywordflow">if</span> (!empty())</div>
<div class="line">                merge();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /** Helper function for computing the size of the 2/3 subproblem. */</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> size_type subp_size(size_type n)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (n / 3) * 2 + ((n % 3) == 2);</div>
<div class="line">    }</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Sort mod0-quints / mod1-quads / mod2-quints and run merge_sa class to</span></div>
<div class="line"><span class="comment">     * merge them together.</span></div>
<div class="line"><span class="comment">     * @param S input string pipe type.</span></div>
<div class="line"><span class="comment">     * @param Mod1 mod1 tuples input pipe type.</span></div>
<div class="line"><span class="comment">     * @param Mod2 mod2 tuples input pipe type.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> S, <span class="keyword">class</span> Mod1, <span class="keyword">class</span> Mod2&gt;</div>
<div class="line">    <span class="keyword">class </span>build_sa</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> offset_type value_type;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> add_rank = 1;  <span class="comment">// free first rank to mark ranks beyond end of input</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="comment">// mod1 types</span></div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::use_push&lt;skew_quad_type&gt; mod1_push_type;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_creator&lt;mod1_push_type, less_mod1&gt; mod1_runs_type;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> mod1_runs_type::sorted_runs_type sorted_mod1_runs_type;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_merger&lt;sorted_mod1_runs_type, less_mod1&gt; mod1_rm_type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// mod2 types</span></div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::use_push&lt;skew_quint_type&gt; mod2_push_type;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_creator&lt;mod2_push_type, less_mod2&gt; mod2_runs_type;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> mod2_runs_type::sorted_runs_type sorted_mod2_runs_type;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_merger&lt;sorted_mod2_runs_type, less_mod2&gt; mod2_rm_type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// mod0 types</span></div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::use_push&lt;skew_quint_type&gt; mod0_push_type;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_creator&lt;mod0_push_type, less_mod0&gt; mod0_runs_type;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> mod0_runs_type::sorted_runs_type sorted_mod0_runs_type;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_merger&lt;sorted_mod0_runs_type, less_mod0&gt; mod0_rm_type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Merge type</span></div>
<div class="line">        <span class="keyword">typedef</span> merge_sa&lt;mod0_rm_type, mod1_rm_type, mod2_rm_type&gt; merge_sa_type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Functions</span></div>
<div class="line">        less_mod0 c0;</div>
<div class="line">        less_mod1 c1;</div>
<div class="line">        less_mod2 c2;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Runs merger</span></div>
<div class="line">        mod1_rm_type* mod1_result;</div>
<div class="line">        mod2_rm_type* mod2_result;</div>
<div class="line">        mod0_rm_type* mod0_result;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Merger</span></div>
<div class="line">        merge_sa_type* vmerge_sa;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Input</span></div>
<div class="line">        S&amp; source;</div>
<div class="line">        Mod1&amp; mod_1;</div>
<div class="line">        Mod2&amp; mod_2;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Tmp variables</span></div>
<div class="line">        offset_type t[3];</div>
<div class="line">        offset_type old_t2;</div>
<div class="line">        offset_type old_mod2;</div>
<div class="line">        <span class="keywordtype">bool</span> exists[3];</div>
<div class="line">        offset_type mod_one;</div>
<div class="line">        offset_type mod_two;</div>
<div class="line"></div>
<div class="line">        offset_type index;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Empty_flag</span></div>
<div class="line">        <span class="keywordtype">bool</span> ready;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Result</span></div>
<div class="line">        value_type result;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        build_sa(S&amp; source_, Mod1&amp; mod_1_, Mod2&amp; mod_2_, size_type a_size, <span class="keywordtype">size_t</span> memsize)</div>
<div class="line">            : source(source_), mod_1(mod_1_), mod_2(mod_2_), index(0), ready(false)</div>
<div class="line">        {</div>
<div class="line">            assert(!source_.empty());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Runs storage</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">// input: ISA_1,2 from previous level</span></div>
<div class="line">            mod0_runs_type mod0_runs(c0, memsize / 4);</div>
<div class="line">            mod1_runs_type mod1_runs(c1, memsize / 4);</div>
<div class="line">            mod2_runs_type mod2_runs(c2, memsize / 4);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">while</span> (!source.empty())</div>
<div class="line">            {</div>
<div class="line">                exists[0] = <span class="keyword">false</span>;</div>
<div class="line">                exists[1] = <span class="keyword">false</span>;</div>
<div class="line">                exists[2] = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (!source.empty()) {</div>
<div class="line">                    t[0] = *source;</div>
<div class="line">                    ++source;</div>
<div class="line">                    exists[0] = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (!source.empty()) {</div>
<div class="line">                    assert(!mod_1.empty());</div>
<div class="line">                    t[1] = *source;</div>
<div class="line">                    ++source;</div>
<div class="line">                    mod_one = *mod_1 + add_rank;</div>
<div class="line">                    ++mod_1;</div>
<div class="line">                    exists[1] = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (!source.empty()) {</div>
<div class="line">                    assert(!mod_2.empty());</div>
<div class="line">                    t[2] = *source;</div>
<div class="line">                    ++source;</div>
<div class="line">                    mod_two = *mod_2 + add_rank;</div>
<div class="line">                    ++mod_2;</div>
<div class="line">                    exists[2] = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Check special cases in the middle of &quot;source&quot;</span></div>
<div class="line">                <span class="comment">// Cases are cx|xc cxx|cxx and cxxc|xxc</span></div>
<div class="line"></div>
<div class="line">                assert(t[0] != offset_type(0));</div>
<div class="line">                assert(t[1] != offset_type(0));</div>
<div class="line">                assert(t[2] != offset_type(0));</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Mod 0 : (index0,char0,char1,mod1,mod2)</span></div>
<div class="line">                <span class="comment">// Mod 1 : (index1,mod1,char1,mod2)</span></div>
<div class="line">                <span class="comment">// Mod 2 : (index2,mod2)</span></div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (exists[2]) { <span class="comment">// Nothing is missed</span></div>
<div class="line">                    mod0_runs.push(skew_quint_type(index, t[0], t[1], mod_one, mod_two));</div>
<div class="line">                    mod1_runs.push(skew_quad_type(index + 1, mod_one, t[1], mod_two));</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> (index != offset_type(0)) {</div>
<div class="line">                        mod2_runs.push(skew_quint_type((index - 1), old_mod2, old_t2, t[0], mod_one));</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exists[1]) { <span class="comment">// Last element missed</span></div>
<div class="line">                    mod0_runs.push(skew_quint_type(index, t[0], t[1], mod_one, 0));</div>
<div class="line">                    mod1_runs.push(skew_quad_type(index + 1, mod_one, t[1], 0));</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> (index != offset_type(0)) {</div>
<div class="line">                        mod2_runs.push(skew_quint_type((index - 1), old_mod2, old_t2, t[0], mod_one));</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> { <span class="comment">// Only one element left</span></div>
<div class="line">                    assert(exists[0]);</div>
<div class="line">                    mod0_runs.push(skew_quint_type(index, t[0], 0, 0, 0));</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> (index != offset_type(0)) {</div>
<div class="line">                        mod2_runs.push(skew_quint_type((index - 1), old_mod2, old_t2, t[0], 0));</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                old_mod2 = mod_two;</div>
<div class="line">                old_t2 = t[2];</div>
<div class="line">                index += 3;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ((a_size % 3) == 0) { <span class="comment">// changed</span></div>
<div class="line">                <span class="keywordflow">if</span> (index != offset_type(0)) {</div>
<div class="line">                    mod2_runs.push(skew_quint_type((index - 1), old_mod2, old_t2, 0, 0));</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            mod0_runs.deallocate();</div>
<div class="line">            mod1_runs.deallocate();</div>
<div class="line">            mod2_runs.deallocate();</div>
<div class="line"></div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;merging S0 = &quot;</span> &lt;&lt; mod0_runs.size() &lt;&lt; <span class="stringliteral">&quot;, S1 = &quot;</span> &lt;&lt; mod1_runs.size()</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;, S2 = &quot;</span> &lt;&lt; mod2_runs.size() &lt;&lt; <span class="stringliteral">&quot; tuples&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Prepare for merging</span></div>
<div class="line"></div>
<div class="line">            mod0_result = <span class="keyword">new</span> mod0_rm_type(mod0_runs.result(), less_mod0(), memsize / 5);</div>
<div class="line">            mod1_result = <span class="keyword">new</span> mod1_rm_type(mod1_runs.result(), less_mod1(), memsize / 5);</div>
<div class="line">            mod2_result = <span class="keyword">new</span> mod2_rm_type(mod2_runs.result(), less_mod2(), memsize / 5);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// output: ISA_1,2 for next level</span></div>
<div class="line">            vmerge_sa = <span class="keyword">new</span> merge_sa_type(*mod0_result, *mod1_result, *mod2_result);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// read first suffix</span></div>
<div class="line">            result = *(*vmerge_sa);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> result;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        build_sa&amp; <a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator ++ </a>()</div>
<div class="line">        {</div>
<div class="line">            assert(vmerge_sa != 0 &amp;&amp; !vmerge_sa-&gt;empty());</div>
<div class="line"></div>
<div class="line">            ++(*vmerge_sa);</div>
<div class="line">            <span class="keywordflow">if</span> (!vmerge_sa-&gt;empty()) {</div>
<div class="line">                result = *(*vmerge_sa);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {  <span class="comment">// cleaning up</span></div>
<div class="line">                assert(vmerge_sa-&gt;empty());</div>
<div class="line">                ready = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">                assert(vmerge_sa != NULL);</div>
<div class="line">                <span class="keyword">delete</span> vmerge_sa, vmerge_sa = NULL;</div>
<div class="line"></div>
<div class="line">                assert(mod0_result != NULL &amp;&amp; mod1_result != NULL &amp;&amp; mod2_result != NULL);</div>
<div class="line">                <span class="keyword">delete</span> mod0_result, mod0_result = NULL;</div>
<div class="line">                <span class="keyword">delete</span> mod1_result, mod1_result = NULL;</div>
<div class="line">                <span class="keyword">delete</span> mod2_result, mod2_result = NULL;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        ~build_sa()</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (vmerge_sa) <span class="keyword">delete</span> vmerge_sa;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (mod0_result) <span class="keyword">delete</span> mod0_result;</div>
<div class="line">            <span class="keywordflow">if</span> (mod1_result) <span class="keyword">delete</span> mod1_result;</div>
<div class="line">            <span class="keywordflow">if</span> (mod2_result) <span class="keyword">delete</span> mod2_result;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> ready;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    /** The skew algorithm.</span></div>
<div class="line"><span class="comment">     *  @param Input type of the input pipe. */</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Input&gt;</div>
<div class="line">    <span class="keyword">class </span>algorithm</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> offset_type value_type;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Input::value_type alphabet_type;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="comment">// finished reading final suffix array</span></div>
<div class="line">        <span class="keywordtype">bool</span> finished;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// current recursion depth</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rec_depth;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="comment">// generate (i) sequence</span></div>
<div class="line">        <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1stream_1_1counter.html">stxxl::stream::counter&lt;offset_type&gt;</a> counter_stream_type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sorter</span></div>
<div class="line">        <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1tuple__less1st.html">stxxl::tuple_less1st&lt;skew_pair_type&gt;</a> mod12cmp;</div>
<div class="line">        <span class="keyword">typedef</span> <a name="_a11"></a><a class="code" href="classstxxl_1_1sorter.html">stxxl::sorter&lt;skew_pair_type, mod12cmp&gt;</a> mod12_sorter_type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Additional streaming items</span></div>
<div class="line">        <span class="keyword">typedef</span> stream::choose&lt;mod12_sorter_type, 2&gt; isa_second_type;</div>
<div class="line">        <span class="keyword">typedef</span> build_sa&lt;offset_array_it_rg, isa_second_type, isa_second_type&gt; buildSA_type;</div>
<div class="line">        <span class="keyword">typedef</span> make_pairs&lt;buildSA_type, counter_stream_type&gt; precompute_isa_type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Real recursive skew3 implementation</span></div>
<div class="line">        <span class="comment">// This part is the core of the skew algorithm and runs all class objects in their respective order</span></div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> RecInputType&gt;</div>
<div class="line">        buildSA_type * skew3(RecInputType&amp; p_Input)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// (t_i) -&gt; (i,t_i,t_{i+1},t_{i+2})</span></div>
<div class="line">            <span class="keyword">typedef</span> make_quads&lt;RecInputType, offset_type, 1&gt; make_quads_input_type;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// (t_i) -&gt; (i,t_i,t_{i+1},t_{i+2}) with i = 1,2 mod 3</span></div>
<div class="line">            <span class="keyword">typedef</span> extract_mod12&lt;make_quads_input_type&gt; mod12_quads_input_type;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// sort (i,t_i,t_{i+1},t_{i+2}) by (t_i,t_{i+1},t_{i+2})</span></div>
<div class="line">            <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::sort&lt;mod12_quads_input_type, less_quad&lt;offset_type&gt; &gt; sort_mod12_input_type;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// name (i,t_i,t_{i+1},t_{i+2}) -&gt; (i,n_i)</span></div>
<div class="line">            <span class="keyword">typedef</span> naming&lt;sort_mod12_input_type&gt; naming_input_type;</div>
<div class="line"></div>
<div class="line">            mod12_sorter_type m1_sorter(mod12cmp(), ram_use / 5);</div>
<div class="line">            mod12_sorter_type m2_sorter(mod12cmp(), ram_use / 5);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// sorted mod1 runs -concatenate- sorted mod2 runs</span></div>
<div class="line">            <span class="keyword">typedef</span> <a name="_a12"></a><a class="code" href="classstxxl_1_1stream_1_1concatenate.html">stxxl::stream::concatenate&lt;mod12_sorter_type, mod12_sorter_type&gt;</a> concatenation_type;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// (t_i) -&gt; (i,t_i,t_{i+1},t_{i+2})</span></div>
<div class="line">            offset_array_type text;</div>
<div class="line">            make_quads_input_type quads_input(p_Input, text);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// (t_i) -&gt; (i,t_i,t_{i+1},t_{i+2}) with i = 1,2 mod 3</span></div>
<div class="line">            mod12_quads_input_type mod12_quads_input(quads_input);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// sort (i,t_i,t_{i+1},t_{i+2}) by (t_i,t_i+1},t_{i+2})</span></div>
<div class="line">            sort_mod12_input_type sort_mod12_input(mod12_quads_input, less_quad&lt;offset_type&gt;(), ram_use / 5);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// name (i,t_i,t_{i+1},t_{i+2}) -&gt; (i,&quot;n_i&quot;)</span></div>
<div class="line">            <span class="keywordtype">bool</span> unique = <span class="keyword">false</span>;         <span class="comment">// is the current quad array unique?</span></div>
<div class="line">            naming_input_type names_input(sort_mod12_input, unique);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// create (i, s^12[i])</span></div>
<div class="line">            size_type concat_length = 0; <span class="comment">// holds length of current S_12</span></div>
<div class="line">            <span class="keywordflow">while</span> (!names_input.empty()) {</div>
<div class="line">                <span class="keyword">const</span> skew_pair_type&amp; tmp = *names_input;</div>
<div class="line">                <span class="keywordflow">if</span> (tmp.first &amp; 1) {</div>
<div class="line">                    m2_sorter.push(tmp); <span class="comment">// sorter #2</span></div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> {</div>
<div class="line">                    m1_sorter.push(tmp); <span class="comment">// sorter #1</span></div>
<div class="line">                }</div>
<div class="line">                ++names_input;</div>
<div class="line">                concat_length++;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;recursion string length = &quot;</span> &lt;&lt; concat_length &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">            m1_sorter.sort();</div>
<div class="line">            m2_sorter.sort();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!unique)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;not unique -&gt; next recursion level = &quot;</span> &lt;&lt; ++rec_depth &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// compute s^12 := lexname[S[1 mod 3]] . lexname[S[2 mod 3]], (also known as reduced recursion string &#39;R&#39;)</span></div>
<div class="line">                concatenation_type concat_mod1mod2(m1_sorter, m2_sorter);</div>
<div class="line"></div>
<div class="line">                buildSA_type* recType = skew3(concat_mod1mod2);  <span class="comment">// recursion with recursion string T&#39; = concat_mod1mod2 lexnames</span></div>
<div class="line"></div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;exit recursion level = &quot;</span> &lt;&lt; --rec_depth &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">                counter_stream_type isa_loop_index;</div>
<div class="line">                precompute_isa_type isa_pairs(*recType, isa_loop_index); <span class="comment">// add index as component =&gt; (SA12, i)</span></div>
<div class="line"></div>
<div class="line">                <span class="comment">// store beginning of mod2-tuples of s^12 in mod2_pos</span></div>
<div class="line">                offset_type special = (concat_length != subp_size(text.size()));</div>
<div class="line">                offset_type mod2_pos = offset_type((subp_size(text.size()) &gt;&gt; 1) + (subp_size(text.size()) &amp; 1) + special);</div>
<div class="line"></div>
<div class="line">                mod12_sorter_type isa1_pair(mod12cmp(), ram_use / 5);</div>
<div class="line">                mod12_sorter_type isa2_pair(mod12cmp(), ram_use / 5);</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">while</span> (!isa_pairs.empty()) {</div>
<div class="line">                    <span class="keyword">const</span> skew_pair_type&amp; tmp = *isa_pairs;</div>
<div class="line">                    <span class="keywordflow">if</span> (tmp.first &lt; mod2_pos) {</div>
<div class="line">                        <span class="keywordflow">if</span> (tmp.first + special &lt; mod2_pos) <span class="comment">// else: special sentinel tuple is dropped</span></div>
<div class="line">                            isa1_pair.push(tmp);            <span class="comment">// sorter #1</span></div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        isa2_pair.push(tmp);                <span class="comment">// sorter #2</span></div>
<div class="line">                    }</div>
<div class="line">                    ++isa_pairs;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keyword">delete</span> recType;</div>
<div class="line"></div>
<div class="line">                isa1_pair.finish();</div>
<div class="line">                isa2_pair.finish();</div>
<div class="line"></div>
<div class="line">                offset_array_it_rg input(text.begin(), text.end());</div>
<div class="line"></div>
<div class="line">                <span class="comment">// =&gt; (i, ISA)</span></div>
<div class="line">                isa1_pair.sort(ram_use / 8);</div>
<div class="line">                isa2_pair.sort(ram_use / 8);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// pick ISA of (i, ISA)</span></div>
<div class="line">                isa_second_type isa1(isa1_pair);</div>
<div class="line">                isa_second_type isa2(isa2_pair);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// prepare and run merger</span></div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">new</span> buildSA_type(input, isa1, isa2, text.size(), ram_use);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="comment">// unique</span></div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;unique names!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">                isa_second_type isa1(m1_sorter);</div>
<div class="line">                isa_second_type isa2(m2_sorter);</div>
<div class="line"></div>
<div class="line">                offset_array_it_rg source(text.begin(), text.end());</div>
<div class="line"></div>
<div class="line">                <span class="comment">// prepare and run merger</span></div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">new</span> buildSA_type(source, isa1, isa2, text.size(), ram_use);</div>
<div class="line">            }</div>
<div class="line">        } <span class="comment">// end of skew3()</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="comment">// Adapt (t_i) -&gt; (i,t_i) for input to fit to recursive call</span></div>
<div class="line">        <span class="keyword">typedef</span> make_pairs&lt;counter_stream_type, Input&gt; make_pairs_input_type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// points to final constructed suffix array generator</span></div>
<div class="line">        buildSA_type* out_sa;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        algorithm(Input&amp; data_in)</div>
<div class="line">            : finished(false), rec_depth(0)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// (t_i) -&gt; (i,t_i)</span></div>
<div class="line">            counter_stream_type dummy;</div>
<div class="line">            make_pairs_input_type pairs_input(dummy, data_in);</div>
<div class="line"></div>
<div class="line">            out_sa = skew3(pairs_input);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> *(*out_sa);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        algorithm&amp; <a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator ++ </a>()</div>
<div class="line">        {</div>
<div class="line">            assert(out_sa);</div>
<div class="line">            assert(!out_sa-&gt;empty());</div>
<div class="line"></div>
<div class="line">            ++(*out_sa);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (out_sa-&gt;empty()) {</div>
<div class="line">                finished = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keyword">delete</span> out_sa;</div>
<div class="line">                out_sa = NULL;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        ~algorithm()</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (out_sa) <span class="keyword">delete</span> out_sa;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> finished;</div>
<div class="line">        }</div>
<div class="line">    }; <span class="comment">// algorithm class</span></div>
<div class="line">};     <span class="comment">// skew class</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">//! helper to print out readable characters.</span></div>
<div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> alphabet_type&gt;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> std::string dumpC(alphabet_type c)</div>
<div class="line">{</div>
<div class="line">    std::ostringstream oss;</div>
<div class="line">    <span class="keywordflow">if</span> (isalnum(c)) oss &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span> &lt;&lt; (char)c &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span>;</div>
<div class="line">    <span class="keywordflow">else</span> oss &lt;&lt; (int)c;</div>
<div class="line">    <span class="keywordflow">return</span> oss.str();</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">//! helper stream to cut input off a specified length.</span></div>
<div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputType&gt;</div>
<div class="line"><span class="keyword">class </span>cut_stream</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    //! same value type as input stream</span></div>
<div class="line"><span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> InputType::value_type value_type;</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    //! instance of input stream</span></div>
<div class="line"><span class="comment"></span>    InputType&amp; m_input;</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    //! counter after which the stream ends</span></div>
<div class="line"><span class="comment"></span>    size_type m_count;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    cut_stream(InputType&amp; input, size_type <a name="a13"></a><a class="code" href="namespacestxxl.html#a1d17ea30c238d8f4ea22b723a55fd662">count</a>)</div>
<div class="line">        : m_input(input), m_count(count)</div>
<div class="line">    { }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        assert(m_count &gt; 0);</div>
<div class="line">        <span class="keywordflow">return</span> *m_input;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    cut_stream&amp; <a class="code" href="uint__types_8h.html#ab3b8e87c6048edbab667d8c19812d6eb">operator ++ </a>()</div>
<div class="line">    {</div>
<div class="line">        assert(!empty());</div>
<div class="line">        --m_count;</div>
<div class="line">        ++m_input;</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (m_count == 0) || m_input.empty();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">alphabet_type unary_generator()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="charliteral">&#39;a&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> offset_type&gt;</div>
<div class="line"><span class="keywordtype">int</span> process(<span class="keyword">const</span> std::string&amp; input_filename, <span class="keyword">const</span> std::string&amp; output_filename,</div>
<div class="line">            size_type sizelimit,</div>
<div class="line">            <span class="keywordtype">bool</span> text_output_flag, <span class="keywordtype">bool</span> check_flag, <span class="keywordtype">bool</span> input_verbatim)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> block_size = <span class="keyword">sizeof</span>(offset_type) * 1024 * 1024 / 2;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1vector.html">stxxl::VECTOR_GENERATOR&lt;alphabet_type, 1, 2&gt;::result</a> alphabet_vector_type;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1vector.html">stxxl::VECTOR_GENERATOR&lt;offset_type, 1, 2, block_size&gt;::result</a> offset_vector_type;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input and output files (if supplied via command line)</span></div>
<div class="line">    <a name="_a14"></a><a class="code" href="classstxxl_1_1syscall__file.html">stxxl::syscall_file</a>* input_file = NULL, * output_file = NULL;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// input and output vectors for suffix array construction</span></div>
<div class="line">    alphabet_vector_type input_vector;</div>
<div class="line">    offset_vector_type output_vector;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> <a name="_a15"></a><a class="code" href="classstxxl_1_1file.html">stxxl::file</a>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (input_verbatim)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// copy input verbatim into vector</span></div>
<div class="line">        input_vector.resize(input_filename.size());</div>
<div class="line">        std::copy(input_filename.begin(), input_filename.end(), input_vector.begin());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input_filename == <span class="stringliteral">&quot;random&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (sizelimit == <a name="a16"></a><a class="code" href="uint__types_8h.html#a0cfacbbf6e846521326f5de5ba3ecd05">std::numeric_limits&lt;size_type&gt;::max</a>()) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;You must provide -s &lt;size&gt; for generated inputs.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> 1;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// fill input vector with random bytes</span></div>
<div class="line">        input_vector.resize(sizelimit);</div>
<div class="line">        <a name="_a17"></a><a class="code" href="classstxxl_1_1random__number8__r.html">stxxl::random_number8_r</a> rand8;</div>
<div class="line">        <a name="a18"></a><a class="code" href="group__stlalgo.html#ga1f66b17c000502599f4b98a738094b3a">stxxl::generate</a>(input_vector.begin(), input_vector.end(), rand8);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input_filename == <span class="stringliteral">&quot;unary&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (sizelimit == <a class="code" href="uint__types_8h.html#a0cfacbbf6e846521326f5de5ba3ecd05">std::numeric_limits&lt;size_type&gt;::max</a>()) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;You must provide -s &lt;size&gt; for generated inputs.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> 1;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// fill input vector with random bytes</span></div>
<div class="line">        input_vector.resize(sizelimit);</div>
<div class="line">        <a class="code" href="group__stlalgo.html#ga1f66b17c000502599f4b98a738094b3a">stxxl::generate</a>(input_vector.begin(), input_vector.end(), unary_generator);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// define input file object and map input_vector to input_file (no copying)</span></div>
<div class="line">        input_file = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1syscall__file.html">stxxl::syscall_file</a>(input_filename, file::RDONLY | file::DIRECT);</div>
<div class="line">        alphabet_vector_type file_input_vector(input_file);</div>
<div class="line">        input_vector.swap(file_input_vector);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (output_filename.size())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// define output file object and map output_vector to output_file</span></div>
<div class="line">        output_file = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1syscall__file.html">stxxl::syscall_file</a>(output_filename, file::RDWR | file::CREAT | file::DIRECT);</div>
<div class="line">        offset_vector_type file_output_vector(output_file);</div>
<div class="line">        output_vector.swap(file_output_vector);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// I/O measurement</span></div>
<div class="line">    <a name="_a19"></a><a class="code" href="classstxxl_1_1stats.html">stxxl::stats</a>* Stats = <a name="a20"></a><a class="code" href="classstxxl_1_1singleton.html#ab81b99f8fc8157a2a4b1bdab8afb454b">stxxl::stats::get_instance</a>();</div>
<div class="line">    <a name="_a21"></a><a class="code" href="classstxxl_1_1stats__data.html">stxxl::stats_data</a> stats_begin(*Stats);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// construct skew class with bufreader input type</span></div>
<div class="line">    <span class="keyword">typedef</span> alphabet_vector_type::bufreader_type input_type;</div>
<div class="line">    <span class="keyword">typedef</span> cut_stream&lt;input_type&gt; cut_input_type;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> skew&lt;offset_type&gt;::template algorithm&lt;cut_input_type&gt; skew_type;</div>
<div class="line"></div>
<div class="line">    size_type size = input_vector.size();</div>
<div class="line">    <span class="keywordflow">if</span> (size &gt; sizelimit) size = sizelimit;</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;input size = &quot;</span> &lt;&lt; size &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (size + 3 &gt;= <a class="code" href="uint__types_8h.html#a0cfacbbf6e846521326f5de5ba3ecd05">std::numeric_limits&lt;offset_type&gt;::max</a>()) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;error: input is too long for selected word size!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    input_type input(input_vector);</div>
<div class="line">    cut_input_type cut_input(input, size);</div>
<div class="line">    skew_type skew(cut_input);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// make sure output vector has the right size</span></div>
<div class="line">    output_vector.resize(size);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// write suffix array stream into output vector</span></div>
<div class="line">    <a name="a22"></a><a class="code" href="group__streampack.html#gabaafb435e850ebfdef01728414b673f8">stream::materialize</a>(skew, output_vector.begin(), output_vector.end());</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;output size = &quot;</span> &lt;&lt; output_vector.size() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; (<a class="code" href="classstxxl_1_1stats__data.html">stxxl::stats_data</a>(*Stats) - stats_begin); <span class="comment">// print i/o statistics</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text_output_flag)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;resulting suffix array:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; output_vector.size(); i++) {</div>
<div class="line">            std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; output_vector[i] &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// We need a const reference because operator[] would write data</span></div>
<div class="line">            <span class="keyword">const</span> alphabet_vector_type&amp; cinput = input_vector;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; output_vector[i] + j &lt; cinput.size(); j++) {</div>
<div class="line">                std::cout &lt;&lt; dumpC(cinput[output_vector[i] + j]) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            std::cout &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> ret = 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (check_flag)</div>
<div class="line">    {</div>
<div class="line">        (std::cout &lt;&lt; <span class="stringliteral">&quot;checking suffix array... &quot;</span>).flush();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!sacheck_vectors(input_vector, output_vector)) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;failed!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            ret = -1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ok.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// close file, but have to deallocate vector first!</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (input_file) {</div>
<div class="line">        input_vector = alphabet_vector_type();</div>
<div class="line">        <span class="keyword">delete</span> input_file;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (output_file) {</div>
<div class="line">        output_vector = offset_vector_type();</div>
<div class="line">        <span class="keyword">delete</span> output_file;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <a name="_a23"></a><a class="code" href="classstxxl_1_1cmdline__parser.html">stxxl::cmdline_parser</a> cp;</div>
<div class="line"></div>
<div class="line">    cp.<a name="a24"></a><a class="code" href="classstxxl_1_1cmdline__parser.html#aa94e3d03fd48f21af08cc237b34bf074">set_description</a>(<span class="stringliteral">&quot;DC3 aka skew3 algorithm for external memory suffix array construction.&quot;</span>);</div>
<div class="line">    cp.<a name="a25"></a><a class="code" href="classstxxl_1_1cmdline__parser.html#a18b3dda858fc13fd774af6a2781c5191">set_author</a>(<span class="stringliteral">&quot;Jens Mehnert &lt;jmehnert@mpi-sb.mpg.de&gt;, Timo Bingmann &lt;tb@panthema.net&gt;, Daniel Feist &lt;daniel.feist@student.kit.edu&gt;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    std::string input_filename, output_filename;</div>
<div class="line">    size_type sizelimit = <a class="code" href="uint__types_8h.html#a0cfacbbf6e846521326f5de5ba3ecd05">std::numeric_limits&lt;size_type&gt;::max</a>();</div>
<div class="line">    <span class="keywordtype">bool</span> text_output_flag = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> check_flag = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> input_verbatim = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">unsigned</span> wordsize = 32;</div>
<div class="line"></div>
<div class="line">    cp.<a name="a26"></a><a class="code" href="classstxxl_1_1cmdline__parser.html#a68747ba66ff3ac1dbd5130e1782391ff">add_param_string</a>(<span class="stringliteral">&quot;input&quot;</span>, <span class="stringliteral">&quot;Path to input file (or verbatim text).\n  The special inputs &#39;random&#39; and &#39;unary&#39; generate such text on-the-fly.&quot;</span>, input_filename);</div>
<div class="line">    cp.<a name="a27"></a><a class="code" href="classstxxl_1_1cmdline__parser.html#abf89271ba1b967b781f9ace37ee774b3">add_flag</a>(<span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;check&quot;</span>, <span class="stringliteral">&quot;Check suffix array for correctness.&quot;</span>, check_flag);</div>
<div class="line">    cp.<a class="code" href="classstxxl_1_1cmdline__parser.html#abf89271ba1b967b781f9ace37ee774b3">add_flag</a>(<span class="charliteral">&#39;t&#39;</span>, <span class="stringliteral">&quot;text&quot;</span>, <span class="stringliteral">&quot;Print out suffix array in readable text.&quot;</span>, text_output_flag);</div>
<div class="line">    cp.<a name="a28"></a><a class="code" href="classstxxl_1_1cmdline__parser.html#aa2e730262ee518815b8d918700944bf2">add_string</a>(<span class="charliteral">&#39;o&#39;</span>, <span class="stringliteral">&quot;output&quot;</span>, <span class="stringliteral">&quot;Output suffix array to given path.&quot;</span>, output_filename);</div>
<div class="line">    cp.<a class="code" href="classstxxl_1_1cmdline__parser.html#abf89271ba1b967b781f9ace37ee774b3">add_flag</a>(<span class="charliteral">&#39;v&#39;</span>, <span class="stringliteral">&quot;verbatim&quot;</span>, <span class="stringliteral">&quot;Consider \&quot;input\&quot; as verbatim text to construct suffix array on.&quot;</span>, input_verbatim);</div>
<div class="line">    cp.<a name="a29"></a><a class="code" href="classstxxl_1_1cmdline__parser.html#adf2df88abbd896b842a569f96b96c887">add_bytes</a>(<span class="charliteral">&#39;s&#39;</span>, <span class="stringliteral">&quot;size&quot;</span>, <span class="stringliteral">&quot;Cut input text to given size, e.g. 2 GiB.&quot;</span>, sizelimit);</div>
<div class="line">    cp.<a class="code" href="classstxxl_1_1cmdline__parser.html#adf2df88abbd896b842a569f96b96c887">add_bytes</a>(<span class="charliteral">&#39;M&#39;</span>, <span class="stringliteral">&quot;memuse&quot;</span>, <span class="stringliteral">&quot;Amount of RAM to use, default: 1 GiB.&quot;</span>, ram_use);</div>
<div class="line">    cp.<a name="a30"></a><a class="code" href="classstxxl_1_1cmdline__parser.html#afdd88ad7e5e0769bc196414f5e12b316">add_uint</a>(<span class="charliteral">&#39;w&#39;</span>, <span class="stringliteral">&quot;wordsize&quot;</span>, <span class="stringliteral">&quot;Set word size of suffix array to 32, 40 or 64 bit, default: 32-bit.&quot;</span>, wordsize);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// process command line</span></div>
<div class="line">    <span class="keywordflow">if</span> (!cp.<a name="a31"></a><a class="code" href="classstxxl_1_1cmdline__parser.html#a7a9015e157a687e67fade0694b08f744">process</a>(argc, argv))</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (wordsize == 32)</div>
<div class="line">        <span class="keywordflow">return</span> process&lt;stxxl::uint32&gt;(input_filename, output_filename, sizelimit,</div>
<div class="line">                                      text_output_flag, check_flag, input_verbatim);</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wordsize == 40)</div>
<div class="line">        <span class="keywordflow">return</span> process&lt;stxxl::uint40&gt;(input_filename, output_filename, sizelimit,</div>
<div class="line">                                      text_output_flag, check_flag, input_verbatim);</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wordsize == 64)</div>
<div class="line">        <span class="keywordflow">return</span> process&lt;stxxl::uint64&gt;(input_filename, output_filename, sizelimit,</div>
<div class="line">                                      text_output_flag, check_flag, input_verbatim);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid wordsize for suffix array: 32, 40 or 64 are allowed.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer"><a href="http://stxxl.sourceforge.net">STXXL 1.4.1</a> - Generated on Wed Oct 29 2014 10:13:25 for STXXL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
