<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>STXXL: Stack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">STXXL
   &#160;<span id="projectnumber">1.4.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('design_stack.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Stack </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Roman Dementiev (2006)</dd></dl>
<p>The I/O efficient stack is perhaps the simplest external memory data structure. Stacks provide only restricted subset of sequence operations: insertion, removal, and inspection of the element at the top of the stack. Stacks are a "last in first out" (LIFO) data structures: the element at the top of a stack is the one that was most recently added. Stacks does not allow iteration through its elements.</p>
<p>The basic variant of EM stack keeps the top <em>k</em> elements in the main memory buffer, where <img class="formulaInl" alt="$ k \leq 2B $" src="form_5.png"/>. If the buffers get empty on a removal call, one block is brought from the disk to the buffers. Therefore at least <em>B</em> removals are required to make one I/O reading a block. Insertions cause no I/Os until the internal buffers get full. In this case to make space the first <em>B</em> elements are written to the disk. Thus a block write happens only after at least <em>B</em> insertions. If we choose the unit of disk transfer to be a multiple of <em>DB</em> (we denote it as a <em>page</em>), set the stack buffer size to <em>2D</em> pages, and evenly assign the blocks of a page to disks we obtain the following amortized running times of the basic operations of stxxl::stack</p>
<table class="doxtable">
<tr>
<th>operation </th><th>internal work </th><th>I/O (amortized)  </th></tr>
<tr>
<td>insertion at the end </td><td><img class="formulaInl" alt="$ \mathcal{O}(1) $" src="form_0.png"/> </td><td><img class="formulaInl" alt="$ \mathcal{O}(1/DB) $" src="form_1.png"/> </td></tr>
<tr>
<td>removal at the end </td><td><img class="formulaInl" alt="$ \mathcal{O}(1) $" src="form_0.png"/> </td><td><img class="formulaInl" alt="$ \mathcal{O}(1/DB) $" src="form_1.png"/> </td></tr>
</table>
<p>The STXXL library contains four different variants of stacks, each implementation is specialized for a certain access pattern:</p>
<ol type="1">
<li>The <a class="el" href="classstxxl_1_1normal__stack.html">stxxl::normal_stack</a> is a general purpose implementation which is the best if the access pattern to the stack is an irregular mix of push'es and pop's, i.e. the stack grows and shrinks without a certain rule.</li>
<li>The <a class="el" href="group__stlcont__stack.html#ggaaea04c2b2dc30f34716e332164d76fb6a599d864b8f91a9a39335c1c545d20f50">stxxl::grow_shrink</a> stack is a stack that is optimized for an access pattern where the insertions are (almost) not intermixed with the removals, and/or vice versa, the removals are (almost) not intermixed with the insertions. In short, the stack first grows to its maximal size, then shrinks, then grow again and so on, a pattern which can be described by <img class="formulaInl" alt="$ (push^{r_i}, push^{r_j})^k $" src="form_6.png"/> with <img class="formulaInl" alt="$ 1 \leq j \leq k $" src="form_7.png"/> and large values for <img class="formulaInl" alt="$ r_i $" src="form_8.png"/> and <img class="formulaInl" alt="$ r_j $" src="form_9.png"/>.</li>
<li><a class="el" href="group__stlcont__stack.html#ggaaea04c2b2dc30f34716e332164d76fb6a1ca0807cfaf63c1b5768604380f654cf">stxxl::grow_shrink2</a> stack is a "grow-shrink" stack that allows the use of common prefetch and write buffer pools. The pools are shared between several "grow-shrink" stacks.</li>
<li><a class="el" href="group__stlcont__stack.html#gga8915cf6dd5ad4199511d708b2e1bd707a97b8f5f651c37e5e0674c64b33e167b3">stxxl::migrating</a> stack is a stack that migrates from internal memory to external memory when its size exceeds a certain threshold (determined by parameter migrating_critical_size)</li>
</ol>
<p>To make use of stxxl::stack, one can use the generator template <a class="el" href="classstxxl_1_1STACK__GENERATOR.html">stxxl::STACK_GENERATOR</a> which expects the parameters from left to right as shown in the table below.</p>
<h1><a class="anchor" id="design_stack_normal"></a>
stxxl::normal_stack</h1>
<p>The <a class="el" href="classstxxl_1_1normal__stack.html">stxxl::normal_stack</a> is a general purpose implementation of the external memory stack. The stack has two pages, the size of the page in blocks is a configuration constant and can be given as a template parameter. The implementation of the methods follows the description given in the previous section.</p>
<h2>Internal Memory Consumption of <a class="el" href="classstxxl_1_1normal__stack.html" title="External stack container.  Introduction  to stack container: see STXXL Stack tutorial.   Design and Internals  of stack container: see Stack Conservative implementation. Fits best if your access pattern consists of irregularly mixed push&#39;es and pop&#39;s. For semantics of the methods see documentation of the STL std::stack.   To gain full bandwidth of disks StackConfig::BlocksPerPage must &gt;= number of disks   ">stxxl::normal_stack</a></h2>
<p>The cache of <a class="el" href="classstxxl_1_1normal__stack.html">stxxl::normal_stack</a> largely dominates in its internal memory consumption. Other members consume very small fraction of <a class="el" href="classstxxl_1_1normal__stack.html">stxxl::normal_stack</a>'s memory even when the stack size is large. Therefore, the internal memory consumption of <a class="el" href="classstxxl_1_1normal__stack.html">stxxl::normal_stack</a> can be estimated as <img class="formulaInl" alt="$ 2 \times BlockSize \times PageSize $" src="form_10.png"/> bytes, where <img class="formulaInl" alt="$ BlockSize $" src="form_11.png"/> is the block size and <img class="formulaInl" alt="$ PageSize $" src="form_12.png"/> is the page size in blocks (see <a class="el" href="design_stack.html">Stack</a>).</p>
<h1><a class="anchor" id="design_stack_grow_shrink"></a>
stxxl::grow_shrink_stack</h1>
<p>The <a class="el" href="classstxxl_1_1grow__shrink__stack.html">stxxl::grow_shrink_stack</a> specialization is optimized for an access pattern where the insertions are (almost) not intermixed with the removals, and/or vice versa, the removals are (almost) not intermixed with the insertions. In other words the stack first grows to its maximal size, then it shrinks, then it might again grow, then shrink, and so forth, i.e. the pattern is <img class="formulaInl" alt="$ (push^{i_j}pop^{r_j})^k $" src="form_13.png"/>, where <img class="formulaInl" alt="$ k \in N $" src="form_14.png"/>, <img class="formulaInl" alt="$ 1 \leq j \leq k $" src="form_7.png"/>, and <img class="formulaInl" alt="$ i_j $" src="form_15.png"/>, <img class="formulaInl" alt="$ r_j $" src="form_9.png"/> are <em>large</em>. The implementation efficiently exploits the knowledge of the access pattern that allows <b>prefetching</b> the blocks beforehand while the stack shrinks and <b>buffered writing</b> while the stack grows. Therefore the <b>overlapping</b> of I/O and computation is possible.</p>
<h2>Internal Memory Consumption of <a class="el" href="classstxxl_1_1grow__shrink__stack.html" title="Efficient implementation that uses prefetching and overlapping using internal buffers. ">stxxl::grow_shrink_stack</a></h2>
<p>The cache of <a class="el" href="classstxxl_1_1grow__shrink__stack.html">stxxl::grow_shrink_stack</a> largely dominates in its internal memory consumption. Other members consume very small fraction of <a class="el" href="classstxxl_1_1grow__shrink__stack.html">stxxl::grow_shrink_stack</a>'s memory even when the stack size is large. Therefore, the internal memory consumption of <a class="el" href="classstxxl_1_1grow__shrink__stack.html" title="Efficient implementation that uses prefetching and overlapping using internal buffers. ">stxxl::grow_shrink_stack</a> can be estimated as <img class="formulaInl" alt="$ 2 \times BlockSize \times PageSize $" src="form_10.png"/> bytes, where <img class="formulaInl" alt="$ BlockSize $" src="form_11.png"/> is the block size and <img class="formulaInl" alt="$ PageSize $" src="form_12.png"/> is the page size in blocks (see <a class="el" href="design_stack.html">Stack</a>).</p>
<h2>Members of <a class="el" href="classstxxl_1_1grow__shrink__stack.html" title="Efficient implementation that uses prefetching and overlapping using internal buffers. ">stxxl::grow_shrink_stack</a></h2>
<p>The <a class="el" href="classstxxl_1_1grow__shrink__stack.html">stxxl::grow_shrink_stack</a> has the same set of members as the <a class="el" href="classstxxl_1_1normal__stack.html">stxxl::normal_stack</a>. The running times of <a class="el" href="classstxxl_1_1grow__shrink__stack.html">stxxl::grow_shrink_stack</a> are the same as <a class="el" href="classstxxl_1_1normal__stack.html">stxxl::normal_stack</a> except that when the stack switches from growing to shrinking (or from shrinking to growing) <img class="formulaInl" alt="$ PageSize $" src="form_12.png"/> I/Os can be spent additionally in the worst case. (This is for the single disk setting, if the page is perfectly striped over parallel disk the number of I/Os is <img class="formulaInl" alt="$ PageSize \cdot D $" src="form_16.png"/>.)</p>
<h1><a class="anchor" id="design_stack_grow_shrink2"></a>
stxxl::grow_shrink_stack2</h1>
<p>The <a class="el" href="classstxxl_1_1grow__shrink__stack2.html">stxxl::grow_shrink_stack2</a> is optimized for the same kind of access pattern as <a class="el" href="classstxxl_1_1grow__shrink__stack.html">stxxl::grow_shrink_stack</a>. The difference is that each instance of <a class="el" href="classstxxl_1_1grow__shrink__stack.html">stxxl::grow_shrink_stack</a> uses an own internal buffer to overlap I/Os and computation, but <a class="el" href="classstxxl_1_1grow__shrink__stack2.html">stxxl::grow_shrink_stack2</a> is able to share the buffers from the pool used by several stacks.</p>
<h2>Internal Memory Consumption of <a class="el" href="classstxxl_1_1grow__shrink__stack2.html" title="Efficient implementation that uses prefetching and overlapping using (shared) buffers pools...">stxxl::grow_shrink_stack2</a></h2>
<p>Not counting the memory consumption of the shared blocks from the pools, the stack alone consumes about <img class="formulaInl" alt="$ BlockSize $" src="form_11.png"/> bytes. It has a cache that consists of only a single block.</p>
<h2>Members of <a class="el" href="classstxxl_1_1grow__shrink__stack2.html" title="Efficient implementation that uses prefetching and overlapping using (shared) buffers pools...">stxxl::grow_shrink_stack2</a></h2>
<p>The <a class="el" href="classstxxl_1_1grow__shrink__stack2.html">stxxl::grow_shrink_stack2</a> has almost the same set of members as the <a class="el" href="classstxxl_1_1normal__stack.html">stxxl::normal_stack</a>, except that it does not have the default constructor. The <a class="el" href="classstxxl_1_1grow__shrink__stack2.html">stxxl::grow_shrink_stack2</a> requires prefetching and write pool objects (see <a class="el" href="classstxxl_1_1prefetch__pool.html">stxxl::prefetch_pool</a>, <a class="el" href="classstxxl_1_1write__pool.html">stxxl::write_pool</a> and <a class="el" href="classstxxl_1_1read__write__pool.html">stxxl::read_write_pool</a>) to be specified in the creation time.</p>
<p>Consequently, the constructor requires a <a class="el" href="classstxxl_1_1read__write__pool.html" title="Implements dynamically resizable buffered writing and prefetched reading pool. ">read_write_pool</a> for prefetching and buffered writing. But it also has a second parameter, which tells how many blocks from the prefetching pool are used, this is called "prefetch_aggressiveness".</p>
<h1><a class="anchor" id="design_stack_grow_migrating"></a>
stxxl::migrating_stack</h1>
<p>The <a class="el" href="classstxxl_1_1migrating__stack.html">stxxl::migrating_stack</a> is a stack that migrates from internal memory to external when its size exceeds a certain threshold (template parameter). The implementation of internal and external memory stacks can be arbitrary and given as a template parameters.</p>
<h2>Internal Memory Consumption of <a class="el" href="classstxxl_1_1migrating__stack.html" title="A stack that migrates from internal memory to external when its size exceeds a certain threshold...">stxxl::migrating_stack</a></h2>
<p>The <a class="el" href="classstxxl_1_1migrating__stack.html">stxxl::migrating_stack</a> memory consumption depends on the memory consumption of the stack implementations given as template parameters. The current state is internal (external), the <a class="el" href="classstxxl_1_1migrating__stack.html">stxxl::migrating_stack</a> consumes almost exactly the same space as internal (external) memory stack implementation. (The <a class="el" href="classstxxl_1_1migrating__stack.html">stxxl::migrating_stack</a> needs only few pointers to maintain the switching from internal to external memory implementations.)</p>
<h2>Members of <a class="el" href="classstxxl_1_1migrating__stack.html" title="A stack that migrates from internal memory to external when its size exceeds a certain threshold...">stxxl::migrating_stack</a></h2>
<p>The <a class="el" href="classstxxl_1_1migrating__stack.html">stxxl::migrating_stack</a> extends the member set of <a class="el" href="classstxxl_1_1normal__stack.html">stxxl::normal_stack</a>. Additionally, there are <a class="el" href="classstxxl_1_1migrating__stack.html#a737d913feda287ab7aaba812e9fc376c">stxxl::migrating_stack::internal()</a> and <a class="el" href="classstxxl_1_1migrating__stack.html#aa9140215d325829b7f407e04bb197072">stxxl::migrating_stack::external()</a>, which return true if the currently used implementation is internal or external.</p>
<h1><a class="anchor" id="design_stack_generator"></a>
stxxl::STACK_GENERATOR</h1>
<p>To provide an easy way to choose and configure the stack implementations, STXXL offers a template meta program called <a class="el" href="classstxxl_1_1STACK__GENERATOR.html">stxxl::STACK_GENERATOR</a>.</p>
<p>The <a class="el" href="classstxxl_1_1STACK__GENERATOR.html">stxxl::STACK_GENERATOR</a> has the following template parameters:</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>type of contained objects (POD with no references to internal memory)</td></tr>
    <tr><td class="paramname">Externality</td><td>selects stack implementation, default: <b>external</b>. One of<ul>
<li><code>external</code>, external container, implementation is chosen according to <code>Behaviour</code> parameter.</li>
<li><code>migrating</code>, migrates from internal implementation given by <code>IntStackType</code> parameter to external implementation given by <code>Behaviour</code> parameter when size exceeds <code>MigrCritSize</code> </li>
<li><code>internal</code>, choses <code>IntStackType</code> implementation</li>
</ul>
</td></tr>
    <tr><td class="paramname">Behaviour</td><td>chooses <b>external</b> implementation, default: <b><a class="el" href="classstxxl_1_1normal__stack.html" title="External stack container.  Introduction  to stack container: see STXXL Stack tutorial.   Design and Internals  of stack container: see Stack Conservative implementation. Fits best if your access pattern consists of irregularly mixed push&#39;es and pop&#39;s. For semantics of the methods see documentation of the STL std::stack.   To gain full bandwidth of disks StackConfig::BlocksPerPage must &gt;= number of disks   ">stxxl::normal_stack</a></b>. One of:<ul>
<li><code>normal</code>, conservative version, implemented in <code><a class="el" href="classstxxl_1_1normal__stack.html" title="External stack container.  Introduction  to stack container: see STXXL Stack tutorial.   Design and Internals  of stack container: see Stack Conservative implementation. Fits best if your access pattern consists of irregularly mixed push&#39;es and pop&#39;s. For semantics of the methods see documentation of the STL std::stack.   To gain full bandwidth of disks StackConfig::BlocksPerPage must &gt;= number of disks   ">stxxl::normal_stack</a></code> </li>
<li><code>grow_shrink</code>, efficient version, implemented in <code><a class="el" href="classstxxl_1_1grow__shrink__stack.html" title="Efficient implementation that uses prefetching and overlapping using internal buffers. ">stxxl::grow_shrink_stack</a></code> </li>
<li><code>grow_shrink2</code>, efficient version, implemented in <code><a class="el" href="classstxxl_1_1grow__shrink__stack2.html" title="Efficient implementation that uses prefetching and overlapping using (shared) buffers pools...">stxxl::grow_shrink_stack2</a></code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">BlocksPerPage</td><td>defines how many blocks has one page of internal cache of an <b>external</b> implementation, default is <b>4</b>. All <b>external</b> implementations have <b>two</b> pages.</td></tr>
    <tr><td class="paramname">BlockSize</td><td>external block size in bytes, default is <b>2 MiB</b>.</td></tr>
    <tr><td class="paramname">IntStackType</td><td>type of internal stack used for some implementations, default: <b>std::stack</b>.</td></tr>
    <tr><td class="paramname">MigrCritSize</td><td>threshold value for number of elements when <a class="el" href="classstxxl_1_1migrating__stack.html" title="A stack that migrates from internal memory to external when its size exceeds a certain threshold...">stxxl::migrating_stack</a> migrates to the external memory, default: <b>2 x BlocksPerPage x BlockSize</b>.</td></tr>
    <tr><td class="paramname">AllocStr</td><td>one of allocation strategies: striping, <a class="el" href="structstxxl_1_1RC.html" title="Randomized cycling disk allocation scheme functor. ">RC</a>, <a class="el" href="structstxxl_1_1SR.html" title="Simple randomized disk allocation scheme functor. ">SR</a>, or <a class="el" href="structstxxl_1_1FR.html" title="Fully randomized disk allocation scheme functor. ">FR</a>. Default is <b><a class="el" href="structstxxl_1_1RC.html" title="Randomized cycling disk allocation scheme functor. ">RC</a></b>.</td></tr>
    <tr><td class="paramname">SizeType</td><td>size type, default is <b><a class="el" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">stxxl::uint64</a></b>.</td></tr>
  </table>
  </dd>
</dl>
<p>The configured stack type is available as <a class="el" href="classstxxl_1_1STACK__GENERATOR.html#ae807c83cad919c405c7703cf6c7ee479">STACK_GENERATOR&lt;&gt;::result</a>.</p>
<h2>Examples:</h2>
<ul>
<li><a class="el" href="classstxxl_1_1STACK__GENERATOR.html#ae807c83cad919c405c7703cf6c7ee479">STACK_GENERATOR&lt;double&gt;::result</a> external stack of <code>double's</code> </li>
<li><a class="el" href="classstxxl_1_1STACK__GENERATOR.html#ae807c83cad919c405c7703cf6c7ee479">STACK_GENERATOR&lt;double,internal&gt;::result</a> internal stack of <code>double's</code> </li>
<li><a class="el" href="classstxxl_1_1STACK__GENERATOR.html#ae807c83cad919c405c7703cf6c7ee479">STACK_GENERATOR&lt;double,external,grow_shrink&gt;::result</a> external grow-shrink stack of <code>double's</code> </li>
<li><a class="el" href="classstxxl_1_1STACK__GENERATOR.html#ae807c83cad919c405c7703cf6c7ee479">STACK_GENERATOR&lt;double,migrating,grow_shrink&gt;::result</a> migrating grow-shrink stack of <code>double's</code>, internal implementation is <code>std::stack&lt;double&gt;</code> </li>
<li><a class="el" href="classstxxl_1_1STACK__GENERATOR.html#ae807c83cad919c405c7703cf6c7ee479">STACK_GENERATOR&lt;double,migrating,grow_shrink,1,512*1024&gt;::result</a> migrating grow-shrink stack of <code>double's</code> with 1 block per page and block size 512 KiB (total memory occupied = 1 MiB)</li>
</ul>
<h2>Example for <a class="el" href="classstxxl_1_1grow__shrink__stack2.html" title="Efficient implementation that uses prefetching and overlapping using (shared) buffers pools...">stxxl::grow_shrink_stack2</a></h2>
<p>TODO-df : but use <a class="el" href="classstxxl_1_1read__write__pool.html" title="Implements dynamically resizable buffered writing and prefetched reading pool. ">read_write_pool</a> instead of the two pools.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> STACK_GENERATOR&lt;int,external,grow_shrink2&gt;::result stack_type;</div>
<div class="line"><span class="keyword">typedef</span> stack_type::block_type block_type;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classstxxl_1_1prefetch__pool.html">stxxl::prefetch_pool</a> p_pool(10); <span class="comment">// 10 read buffers</span></div>
<div class="line"><a class="code" href="classstxxl_1_1write__pool.html">stxxl::write_pool</a> w_pool(6);     <span class="comment">// 6 write buffers</span></div>
<div class="line">stack_type S(p_pool,w_pool,0);   <span class="comment">// no read buffers used</span></div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> i = 0; i &lt; max_value; ++i)</div>
<div class="line">    S.push(i);</div>
<div class="line"></div>
<div class="line">S.set_prefetch_aggressiveness(5);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* give a hint that we are going to shrink the stack from now on,</span></div>
<div class="line"><span class="comment">always prefetch 5 buffers beforehand */</span></div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> i = 0; i &lt; max_value; ++i)</div>
<div class="line">    S.pop();</div>
<div class="line"></div>
<div class="line">S.set_prefetch_aggressiveness(0);</div>
<div class="line"><span class="comment">// stop prefetching</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Welcome to STXXL</a></li><li class="navelem"><a class="el" href="design.html">Design of STXXL</a></li><li class="navelem"><a class="el" href="design_stl.html">The STL-User Layer</a></li><li class="navelem"><a class="el" href="design_stl_containers.html">STXXL Containers</a></li>
    <li class="footer"><a href="http://stxxl.sourceforge.net">STXXL 1.4.1</a> - Generated on Wed Oct 29 2014 10:13:28 for STXXL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
